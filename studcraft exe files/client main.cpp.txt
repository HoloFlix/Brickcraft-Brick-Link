// --- Linker ---
#pragma comment(lib, "SDL2.lib")
#pragma comment(lib, "SDL2main.lib")
#pragma comment(lib, "opengl32.lib")
#pragma comment(lib, "glu32.lib")
#pragma comment(lib, "Ws2_32.lib")
#pragma comment(lib, "glew32.lib")

// ADDED: To suppress fopen warning if not using fopen_s
#define _CRT_SECURE_NO_WARNINGS

// Define M_PI if it's not already defined by cmath/math.h
#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

// --- Includes ---
#include <iostream>
#include <vector>
#include <cmath>
#include <map>
#include <algorithm>
#include <cstdio> // For fopen, fread, fclose

#include "GL/glew.h"

#define NOMINMAX // Prevents min/max macros from interfering
#include "SDL.h"
#include "SDL_opengl.h"
#include <gl/GLU.h> // For gluPerspective and gluLookAt

#include "RakPeerInterface.h"
#include "MessageIdentifiers.h"
#include "BitStream.h"
#include "RakNetTypes.h"
#include "RakString.h"
#include "btBulletCollisionCommon.h" // For btVector3, btQuaternion, btTransform
#include "DataTypes.h" // Assuming this contains your Brick and PlayerState structs

#include "ShaderLoader.h"

// Protocol IDs
const unsigned char ID_PLAYER_ACTION = 0x88;
const unsigned char ID_SERVER_WORLD_DATA = 0x82;
const unsigned char ID_PLAYER_STATES = 0x89;
const unsigned char ID_PLAYER_DISCONNECT_NOTIFICATION = 0x90;

// --- Simple 4x4 Matrix struct for OpenGL math ---
// (Your Matrix4x4 struct definition remains here)
struct Matrix4x4 {
    float m[16]; // Column-major order, as used by OpenGL

    // Default constructor: Initializes to identity matrix
    Matrix4x4() {
        m[0]=1; m[1]=0; m[2]=0; m[3]=0;
        m[4]=0; m[5]=1; m[6]=0; m[7]=0;
        m[8]=0; m[9]=0; m[10]=1; m[11]=0;
        m[12]=0; m[13]=0; m[14]=0; m[15]=1;
    }

    // Matrix multiplication (this * other)
    Matrix4x4 operator*(const Matrix4x4& other) const {
        Matrix4x4 result;
        for (int i = 0; i < 4; ++i) { // Rows of result
            for (int j = 0; j < 4; ++j) { // Columns of result
                result.m[j*4 + i] = // result[row][col] is result.m[col*4 + row]
                    m[0*4 + i] * other.m[j*4 + 0] +
                    m[1*4 + i] * other.m[j*4 + 1] +
                    m[2*4 + i] * other.m[j*4 + 2] +
                    m[3*4 + i] * other.m[j*4 + 3];
            }
        }
        return result;
    }

    // Function to calculate the inverse transpose of the 3x3 submatrix
    // Used for transforming normals. Assumes no non-uniform scaling.
    Matrix4x4 GetNormalMatrix() const {
        Matrix4x4 normalMatrix; // Starts as identity

        // Get 3x3 submatrix (top-left)
        float a11 = m[0], a12 = m[4], a13 = m[8];
        float a21 = m[1], a22 = m[5], a23 = m[9];
        float a31 = m[2], a32 = m[6], a33 = m[10];

        // Calculate determinant of 3x3 submatrix
        float det = a11 * (a22 * a33 - a32 * a23) -
                            a12 * (a21 * a33 - a31 * a23) +
                            a13 * (a21 * a32 - a31 * a22);

        if (fabs(det) < 1e-6) { // Check for singularity (matrix cannot be inverted)
            std::cerr << "Warning: Singular matrix for normal calculation. Returning identity." << std::endl;
            return Matrix4x4(); // Return identity as fallback
        }

        float invDet = 1.0f / det;

        // Calculate inverse of 3x3 submatrix, then transpose (which is the inverse transpose)
        normalMatrix.m[0] = (a22 * a33 - a32 * a23) * invDet; // (row 1, col 1)
        normalMatrix.m[1] = (a31 * a23 - a21 * a33) * invDet; // (row 2, col 1)
        normalMatrix.m[2] = (a21 * a32 - a31 * a22) * invDet; // (row 3, col 1)

        normalMatrix.m[4] = (a32 * a13 - a12 * a33) * invDet; // (row 1, col 2)
        normalMatrix.m[5] = (a11 * a33 - a31 * a13) * invDet; // (row 2, col 2)
        normalMatrix.m[6] = (a31 * a12 - a11 * a32) * invDet; // (row 3, col 2)

        normalMatrix.m[8] = (a12 * a23 - a22 * a13) * invDet; // (row 1, col 3)
        normalMatrix.m[9] = (a21 * a13 - a11 * a23) * invDet; // (row 2, col 3)
        normalMatrix.m[10] = (a11 * a22 - a21 * a12) * invDet; // (row 3, col 3)

        // The other elements of the 4x4 matrix remain as identity for a normal matrix
        normalMatrix.m[3] = normalMatrix.m[7] = normalMatrix.m[11] = 0.0f;
        normalMatrix.m[12] = normalMatrix.m[13] = normalMatrix.m[14] = 0.0f;
        normalMatrix.m[15] = 1.0f;

        return normalMatrix;
    }

    // Load from OpenGL matrix (column-major float[16])
    void LoadFromOpenGL(const float* glMatrix) {
        for(int i = 0; i < 16; ++i) {
            m[i] = glMatrix[i];
        }
    }
};

// Globals
RakNet::RakPeerInterface* g_peer = nullptr;
SDL_Window* g_window = nullptr;
SDL_GLContext g_context;
bool g_is_connected = false;
bool g_quit_app = false;
std::vector<Brick> g_world_bricks;

// Global for our new shader program and its uniform locations
GLuint g_shader_program;
GLint g_loc_model_matrix;
GLint g_loc_view_matrix;
GLint g_loc_projection_matrix;
GLint g_loc_color_id;
GLint g_loc_color_palette;

GLuint g_colorPaletteTextureID = 0;

PlayerState g_self_state;
std::map<RakNet::RakNetGUID, PlayerState> g_other_players;

// Removed g_current_yaw, as it's now authoritative from the server via player_rot.
float g_current_pitch = 0.0f; // Keep this for local camera pitch (head bob)

// Forward Declarations
void Render();
void SendInputToServer(float dYaw, float dPitch);
void HandleNetworkPacket(RakNet::Packet* packet);
GLuint LoadBMPAs1DTexture(const char* imagepath);
void DrawCube(float scale_x, float scale_y, float scale_z);
void RenderPlayer(const PlayerState& state, bool is_self);


// --- Helper function to draw a simple, centered cube ---
void DrawCube(float scale_x, float scale_y, float scale_z) {
    glPushMatrix();
    glScalef(scale_x * 0.5f, scale_y * 0.5f, scale_z * 0.5f); // Scale from center
    glBegin(GL_QUADS);
        // Top Face
        glNormal3f(0.0f, 1.0f, 0.0f);
        glVertex3f( 1.0f, 1.0f,-1.0f); glVertex3f(-1.0f, 1.0f,-1.0f);
        glVertex3f(-1.0f, 1.0f, 1.0f); glVertex3f( 1.0f, 1.0f, 1.0f);
        // Bottom Face
        glNormal3f(0.0f, -1.0f, 0.0f);
        glVertex3f( 1.0f,-1.0f, 1.0f); glVertex3f(-1.0f,-1.0f, 1.0f);
        glVertex3f(-1.0f,-1.0f,-1.0f); glVertex3f( 1.0f,-1.0f,-1.0f);
        // Front Face
        glNormal3f(0.0f, 0.0f, 1.0f);
        glVertex3f( 1.0f, 1.0f, 1.0f); glVertex3f(-1.0f, 1.0f, 1.0f);
        glVertex3f(-1.0f,-1.0f, 1.0f); glVertex3f( 1.0f,-1.0f, 1.0f);
        // Back Face
        glNormal3f(0.0f, 0.0f, -1.0f);
        glVertex3f( 1.0f,-1.0f,-1.0f); glVertex3f(-1.0f,-1.0f,-1.0f);
        glVertex3f(-1.0f, 1.0f,-1.0f); glVertex3f( 1.0f, 1.0f,-1.0f);
        // Left Face
        glNormal3f(-1.0f, 0.0f, 0.0f);
        glVertex3f(-1.0f, 1.0f, 1.0f); glVertex3f(-1.0f,-1.0f, 1.0f); // Corrected Y from -0.0f to -1.0f
        glVertex3f(-1.0f,-1.0f,-1.0f); glVertex3f(-1.0f, 1.0f,-1.0f);
        // Right Face
        glNormal3f(1.0f, 0.0f, 0.0f);
        glVertex3f( 1.0f, 1.0f,-1.0f); glVertex3f( 1.0f,-1.0f,-1.0f);
        glVertex3f( 1.0f,-1.0f, 1.0f); glVertex3f( 1.0f, 1.0f, 1.0f);
    glEnd();
    glPopMatrix();
}

// --- REVISED: Renders a player model correctly positioned and without Z-fighting ---
void RenderPlayer(const PlayerState& state, bool is_self) {
    // 1. Get the authoritative position and rotation from the server
    btVector3 pos(state.position.x, state.position.y, state.position.z);
    btQuaternion rot = state.rotation;

    glPushMatrix(); // Start a new matrix scope for this player

    // 2. THIS IS THE FIX for the "sunk in floor" problem.
    // Our physics capsule is 2.0 units tall (1.2 height + 2*0.4 radius). Its origin is
    // at its center. So, we need to translate our visual model UP by half its height (1.0).
    // This aligns the bottom of the visual model with the ground (y=0).
    glTranslatef(pos.x(), pos.y() +0.4f, pos.z());

    // 3. Apply the server's rotation for the body's yaw.
    btTransform body_transform(rot);
    float mat[16];
    body_transform.getOpenGLMatrix(mat);
    glMultMatrixf(mat);

    // --- Render a single Body block to prevent Z-fighting ---
    // Instead of multiple small bricks that might Z-fight, we draw one taller block.
    glUniform1i(g_loc_color_id, 7); // Grey color

    float model_matrix_raw[16];
    glGetFloatv(GL_MODELVIEW_MATRIX, model_matrix_raw);
    glUniformMatrix4fv(g_loc_model_matrix, 1, GL_FALSE, model_matrix_raw);

    // Draw a single tall "body" brick.
    // The total height of the player model is 2.0 (body 1.2 + head 0.4 + gap 0.4).
    // The physics capsule is 2.0 tall. So the body height should be 1.2 to match.
    // The width/depth (1.0, 0.5) are half-extents for DrawCube, so actual dimensions are 2.0x1.0.
    DrawCube(1.0f, 1.2f, 0.5f); // Draw a single tall "body" brick

    // --- Render Head ---
    if (!is_self) { // Only draw heads for other players
        glUniform1i(g_loc_color_id, 4); // Red color

        glPushMatrix();
        // Position head above the body.
        // Body is 1.2 units tall. Head is 0.4 units tall.
        // We want a small gap, e.g., 0.2 units.
        // So, translate by (1.2/2) + (0.4/2) + 0.2 = 0.6 + 0.2 + 0.2 = 1.0 from body center.
        // Or simply, 0.6f is the top of the body, then add 0.2f for gap, then 0.2f for half head height.
        // A simpler way: if body is centered at 0,0,0 and is 1.2 tall, its top is at 0.6.
        // Head is 0.4 tall, so its center should be at 0.6 + (0.4/2) = 0.6 + 0.2 = 0.8.
        glTranslatef(0.0f, 0.8f, 0.0f); 

        glGetFloatv(GL_MODELVIEW_MATRIX, model_matrix_raw);
        glUniformMatrix4fv(g_loc_model_matrix, 1, GL_FALSE, model_matrix_raw);

        DrawCube(1.0f, 0.4f, 0.5f); // Draw head brick
        glPopMatrix();
    }

    glPopMatrix(); // End this player's matrix scope
}


// --- LoadBMPAs1DTexture function definition ---
GLuint LoadBMPAs1DTexture(const char* imagepath) {
    std::cout << "Reading image " << imagepath << std::endl;

    unsigned char header[54];
    unsigned int dataPos;
    unsigned int width, height;
    unsigned int imageSize;
    unsigned char *data;

    FILE* file;
    if (fopen_s(&file, imagepath, "rb") != 0) {
        std::cerr << "Image could not be opened: " << imagepath << std::endl;
        return 0;
    }

    if (fread(header, 1, 54, file) != 54) {
        std::cerr << "Not a correct BMP file" << std::endl;
        fclose(file);
        return 0;
    }
    if (header[0] != 'B' || header[1] != 'M') {
        std::cerr << "Not a correct BMP file" << std::endl;
        fclose(file);
        return 0;
    }

    dataPos = *(int*)&(header[0x0A]);
    imageSize = *(int*)&(header[0x22]);
    width = *(int*)&(header[0x12]);
    height = *(int*)&(header[0x16]);

    if (imageSize == 0) imageSize = width * height * 3;
    if (dataPos == 0) dataPos = 54;

    data = new unsigned char[imageSize];
    fread(data, 1, imageSize, file);
    fclose(file);

    GLuint textureID;
    glGenTextures(1, &textureID);
    glBindTexture(GL_TEXTURE_1D, textureID);
    glTexImage1D(GL_TEXTURE_1D, 0, GL_RGB, width, 0, GL_BGR, GL_UNSIGNED_BYTE, data);
    delete[] data;

    glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);

    std::cout << "Successfully loaded texture " << imagepath << " with ID " << textureID << std::endl;
    return textureID;
}


int main(int argc, char* argv[]) {
    SDL_Init(SDL_INIT_VIDEO);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 2);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 1);
    SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);
    g_window = SDL_CreateWindow("Studcraft Client", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 1280, 720, SDL_WINDOW_OPENGL | SDL_WINDOW_SHOWN);
    g_context = SDL_GL_CreateContext(g_window);
    glEnable(GL_DEPTH_TEST);

    glewExperimental = GL_TRUE;
    GLenum err = glewInit();
    if (GLEW_OK != err) {
        std::cerr << "Error: " << glewGetErrorString(err) << std::endl;
        return 1;
    }
    std::cout << "[INFO] GLEW Initialized." << std::endl;
    
    g_colorPaletteTextureID = LoadBMPAs1DTexture("assets/LegoColors.bmp");
    if (g_colorPaletteTextureID == 0) {
        std::cerr << "Failed to load color palette texture. Exiting." << std::endl;
        return 1;
    }

    g_shader_program = ShaderLoader::Load("assets/shaders/brick.vert", "assets/shaders/brick.frag");
    std::cout << "[INFO] Shaders loaded." << std::endl;

    // Get uniform locations for the NEW brick shader
    g_loc_model_matrix      = glGetUniformLocation(g_shader_program, "model");
    g_loc_view_matrix       = glGetUniformLocation(g_shader_program, "view");
    g_loc_projection_matrix = glGetUniformLocation(g_shader_program, "projection");
    g_loc_color_id          = glGetUniformLocation(g_shader_program, "color_id");
    g_loc_color_palette     = glGetUniformLocation(g_shader_program, "colorPalette");

    // Check if uniforms were found (this is good for debugging)
    if (g_loc_model_matrix == -1)      std::cerr << "Warning: 'model' uniform not found." << std::endl;
    if (g_loc_view_matrix == -1)       std::cerr << "Warning: 'view' uniform not found." << std::endl;
    if (g_loc_projection_matrix == -1) std::cerr << "Warning: 'projection' uniform not found." << std::endl;
    if (g_loc_color_id == -1)          std::cerr << "Warning: 'color_id' uniform not found." << std::endl;
    if (g_loc_color_palette == -1)     std::cerr << "Warning: 'colorPalette' uniform not found." << std::endl;

    g_peer = RakNet::RakPeerInterface::GetInstance();
    RakNet::SocketDescriptor sd;
    g_peer->Startup(1, &sd, 1);
    g_peer->Connect("127.0.0.1", 37373, 0, 0);
    SDL_SetRelativeMouseMode(SDL_TRUE);
    
    // --- Main Game Loop ---
    while (!g_quit_app) {
        // --- Input State ---
        float frame_delta_yaw = 0.0f;
        float frame_delta_pitch = 0.0f;

        // --- Event Polling ---
        SDL_Event e;
        while(SDL_PollEvent(&e) != 0) {
            if(e.type == SDL_QUIT) {
                g_quit_app = true;
            }
            if(e.type == SDL_MOUSEMOTION) {
                // Accumulate mouse movement for sending to server and local pitch
                frame_delta_yaw += (float)e.motion.xrel * 0.2f;
                g_current_pitch += (float)e.motion.yrel * 0.2f;
            }
        }

        // --- Update Local Camera Pitch ---
        // Clamp pitch to prevent the camera from flipping over
        g_current_pitch = std::max(-89.0f, std::min(89.0f, g_current_pitch));

        // --- Network Packet Processing ---
        for (RakNet::Packet* p = g_peer->Receive(); p; g_peer->DeallocatePacket(p), p = g_peer->Receive()) {
            HandleNetworkPacket(p);
        }

        // --- Send Input to Server (if connected) ---
        if (g_is_connected) {
            SendInputToServer(frame_delta_yaw, frame_delta_pitch);
        }

        // --- Render the Scene ---
        Render();

        // --- Frame Limiter ---
        SDL_Delay(15);
    }
    
    // --- Cleanup ---
    glDeleteProgram(g_shader_program); 
    glDeleteTextures(1, &g_colorPaletteTextureID);

    RakNet::RakPeerInterface::DestroyInstance(g_peer);
    SDL_GL_DeleteContext(g_context);
    SDL_DestroyWindow(g_window);
    SDL_Quit();
    return 0;
}


// --- Function Definitions ---

void HandleNetworkPacket(RakNet::Packet* packet) {
    RakNet::BitStream bs_in(packet->data, packet->length, false);
    unsigned char msgId;
    bs_in.Read(msgId);
    
    switch (msgId) {
        case ID_CONNECTION_REQUEST_ACCEPTED:
            g_is_connected = true;
            std::cout << "Connected to server." << std::endl;
            break;
        case ID_NO_FREE_INCOMING_CONNECTIONS:
        case ID_DISCONNECTION_NOTIFICATION:
        case ID_CONNECTION_LOST:
            g_is_connected = false;
            g_quit_app = true; // Set to true to exit cleanly
            std::cout << "Disconnected from server." << std::endl;
            break;

        case ID_SERVER_WORLD_DATA: {
            Vector3 temp_spawn; bs_in.Read(temp_spawn);
            unsigned int brick_count; bs_in.Read(brick_count);
            g_world_bricks.clear(); g_world_bricks.reserve(brick_count);
            for(unsigned int i=0; i<brick_count; ++i) { Brick b; bs_in.Read((char*)&b, sizeof(Brick)); g_world_bricks.push_back(b); }
            std::cout << "[WORLD] Received and parsed " << brick_count << " bricks." << std::endl;
            break;
        }

        case ID_PLAYER_STATES: {
            unsigned int num_players;
            bs_in.Read(num_players);
            g_other_players.clear();
            for(unsigned int i=0; i < num_players; ++i) {
                PlayerState ps;
                bs_in.Read((char*)&ps, sizeof(PlayerState));
                if(ps.guid == g_peer->GetMyGUID()){
                    g_self_state = ps;
                } else {
                    g_other_players[ps.guid] = ps;
                }
            }
            break;
        }

        case ID_PLAYER_DISCONNECT_NOTIFICATION: {
            RakNet::RakNetGUID disconnected_guid;
            bs_in.Read(disconnected_guid);
            g_other_players.erase(disconnected_guid);
            std::cout << "Player with GUID " << disconnected_guid.ToString() << " disconnected." << std::endl;
            break;
        }

        case ID_REPLICA_MANAGER_CONSTRUCTION:
        case ID_REPLICA_MANAGER_SERIALIZE:
        {
            if (msgId == ID_REPLICA_MANAGER_CONSTRUCTION) {
                RakNet::RakString name; bs_in.Read(name);
            }
            
            RakNet::RakNetGUID guid;
            bs_in.Read(guid);

            btTransform transform;
            bs_in.Read(transform);
            
            if (guid == g_peer->GetMyGUID()) {
                btVector3 pos = transform.getOrigin();
                g_self_state.position.x = pos.x();
                g_self_state.position.y = pos.y();
                g_self_state.position.z = pos.z();
                g_self_state.rotation = transform.getRotation();
            }
            break;
        }

        default:
            std::cout << "Unhandled Message ID: " << (int)msgId << std::endl;
            break;
    }
}

void SendInputToServer(float dYaw, float dPitch) {
    const Uint8* keyState = SDL_GetKeyboardState(NULL);
    PlayerInput input = {0};
    input.is_forward_pressed = (keyState[SDL_SCANCODE_W]!=0);
    input.is_backward_pressed = (keyState[SDL_SCANCODE_S]!=0);
    input.is_left_pressed = (keyState[SDL_SCANCODE_A]!=0);
    input.is_right_pressed = (keyState[SDL_SCANCODE_D]!=0);
    input.is_jump_pressed = (keyState[SDL_SCANCODE_SPACE]!=0);
    input.delta_yaw = dYaw;
    input.delta_pitch = dPitch;
    RakNet::BitStream bs_out;
    bs_out.Write((unsigned char)ID_PLAYER_ACTION);
    bs_out.Write(input);
    g_peer->Send(&bs_out, LOW_PRIORITY, UNRELIABLE_SEQUENCED, 0, RakNet::UNASSIGNED_SYSTEM_ADDRESS, true);
}


// --- Corrected Render() function to address getEulerZYX error ---
void Render() {
    int w, h;
    SDL_GetWindowSize(g_window, &w, &h);
    glViewport(0, 0, w, h);

    // --- Scene Setup ---
    glClearColor(0.5f, 0.8f, 1.0f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    // --- Set Projection Matrix (Field of View) ---
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(70.0f, (GLfloat)w / (GLfloat)h, 0.1f, 1000.0f);

    // --- Build View Matrix (The Camera) ---
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    // The camera's transformation is the inverse of the player's world transformation.

    // 1. Create a Bullet transform for the camera.
    // It starts with the player's server-authoritative rotation (yaw).
    btTransform cameraTransform;
    // For pure yaw, it's better to explicitly create a quaternion only for yaw from the server's state.
    // First, extract yaw from the server's quaternion using btMatrix3x3.
    btScalar roll, pitch, yaw_radians;
    btMatrix3x3 mat(g_self_state.rotation);
    mat.getEulerZYX(roll, pitch, yaw_radians);

    // Create a new quaternion that *only* represents the yaw from the server.
    btQuaternion server_yaw_quat(btVector3(0,1,0), yaw_radians); // Yaw around Y-axis

    // Combine this server-side yaw with the client-side pitch.
    // Pitch is applied locally to the camera's orientation.
    btQuaternion client_pitch_quat(btVector3(1,0,0), -g_current_pitch * (M_PI / 180.0f)); // Pitch around X-axis

    // Combine pitch and yaw. Order matters: Pitch relative to Yaw.
    // The camera's final orientation is (inverse_of_yaw * inverse_of_pitch).
    // In OpenGL's glMultMatrixf (which post-multiplies), we apply transformations
    // in the reverse order of what they affect.
    // So, we want to transform the world by (inverse_pos * inverse_yaw * inverse_pitch).
    // This translates to glTranslate(-pos) then glMultMatrix(inverse(yaw*pitch))
    // OR: Create the camera's transform directly, then invert it.

    // Let's build the camera's local transform directly, then get its inverse for the view matrix.
    // Camera's local orientation: Apply yaw, then apply pitch relative to that yaw.
    // Bullet quaternion multiplication: q_final = q_initial * q_rotation_relative_to_q_initial
    btQuaternion combined_camera_rotation = server_yaw_quat * client_pitch_quat;

    // Set the position of the camera. It's the player's position + eye height.
    btVector3 eye_pos = btVector3(g_self_state.position.x, g_self_state.position.y + 1.6f, g_self_state.position.z);

    // Set the transform for the camera: position and combined rotation
    cameraTransform.setOrigin(eye_pos);
    cameraTransform.setRotation(combined_camera_rotation); // This is the camera's world transform

    // To get the VIEW matrix, we need the INVERSE of the camera's world transform.
    btTransform viewTransform = cameraTransform.inverse();

    // Convert the inverse transform to an OpenGL matrix
    float view_matrix_gl[16];
    viewTransform.getOpenGLMatrix(view_matrix_gl);
    glMultMatrixf(view_matrix_gl); // Apply the view matrix


    // --- The rest of the rendering remains the same! ---
    glUseProgram(g_shader_program);

    float proj_matrix_raw[16]; glGetFloatv(GL_PROJECTION_MATRIX, proj_matrix_raw);
    float view_matrix_raw[16]; glGetFloatv(GL_MODELVIEW_MATRIX, view_matrix_raw); // This will now get the matrix from glMultMatrixf
    glUniformMatrix4fv(g_loc_projection_matrix, 1, GL_FALSE, proj_matrix_raw);
    glUniformMatrix4fv(g_loc_view_matrix, 1, GL_FALSE, view_matrix_raw);

    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_1D, g_colorPaletteTextureID);
    glUniform1i(g_loc_color_palette, 0);


    // --- Render World Bricks ---
    for (size_t i = 0; i < g_world_bricks.size(); ++i) {
        const Brick& brick = g_world_bricks[i];
        glPushMatrix();
        glTranslatef(brick.x, brick.y, brick.z);
        
        float model_matrix_raw[16];
        glGetFloatv(GL_MODELVIEW_MATRIX, model_matrix_raw);
        glUniformMatrix4fv(g_loc_model_matrix, 1, GL_FALSE, model_matrix_raw);
        glUniform1i(g_loc_color_id, brick.c_id);
        DrawCube(2.0f, 0.2f, 2.0f);
        glPopMatrix();
    }


    // --- Render Other Players ---
    for (std::map<RakNet::RakNetGUID, PlayerState>::const_iterator it = g_other_players.begin(); it != g_other_players.end(); ++it) {
        RenderPlayer(it->second, false);
    }

    RenderPlayer(g_self_state, true); // Keep this for debugging / optional third-person view

    // --- Deactivate Shader ---
    glUseProgram(0);

    SDL_GL_SwapWindow(g_window);
}