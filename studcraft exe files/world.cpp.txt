#include "World.h"
#include "btBulletDynamicsCommon.h" // Include the full header for implementation

// Default constructor (NEW)
World::World() : physicsWorld(nullptr) {}

// The constructor now takes the physics world and stores it.
World::World(btDiscreteDynamicsWorld* dynamicsWorld) : physicsWorld(dynamicsWorld) {}

// Destructor to clean up physics objects created by this World
World::~World() {
    // The destructor now simply calls Clear() to perform cleanup.
    Clear();
}

void World::Clear() {
    // This is the safe way to do what the destructor does:
    // 1. Remove rigid bodies from the physics world first.
    if (physicsWorld) {
        for (size_t i = 0; i < rigidBodies.size(); ++i) {
            if (rigidBodies[i]) { // Defensive check
                physicsWorld->removeRigidBody(rigidBodies[i]);
            }
        }
    }

    // 2. Delete allocated physics objects from memory.
    // Ensure you delete each pointer individually.
    for (size_t i = 0; i < rigidBodies.size(); ++i) {
        delete rigidBodies[i];
    }
    for (size_t i = 0; i < motionStates.size(); ++i) {
        delete motionStates[i];
    }
    for (size_t i = 0; i < collisionShapes.size(); ++i) {
        delete collisionShapes[i];
    }

    // 3. Clear the vectors to remove all elements and free their memory.
    bricks.clear();
    rigidBodies.clear();
    motionStates.clear();
    collisionShapes.clear();
}


void World::GenerateSimplePlatform() {
    // Call Clear() to safely remove any existing bricks and physics objects
    // before generating a new platform. This prevents memory leaks and issues
    // if GenerateSimplePlatform is called multiple times.
    Clear();

    const int world_size = 16;
    const float brick_step = 2.0f; // Distance between brick centers

    for (int i = -world_size / 2; i < world_size / 2; ++i) {
        for (int j = -world_size / 2; j < world_size / 2; ++j) {
            Brick floor_tile = {0}; // Initialize to zeros
            floor_tile.x = (float)i * brick_step;
            floor_tile.y = 0.0f; // Visual Y position for the bottom of the brick
            floor_tile.z = (float)j * brick_step;

            floor_tile.id = 1;   // Example ID
            floor_tile.c_id = 7; // Example color ID

            bricks.push_back(floor_tile);

            // --- Physics Body Creation for each brick ---
            if (this->physicsWorld) {
                // 1. Define the collision shape. A box of 1x0.1x1 units.
                //    btBoxShape takes half-extents, so a 2x0.2x2 brick needs (1.0f, 0.1f, 1.0f)
                btCollisionShape* groundShape = new btBoxShape(btVector3(1.0f, 0.1f, 1.0f));
                collisionShapes.push_back(groundShape); // Store for cleanup

                // 2. Set its initial position and orientation in the world.
                //    The physics body's origin (center) should align with the visual brick's center.
                //    If floor_tile.y is the visual bottom, the physics body's center is floor_tile.y + half_height.
                btTransform groundTransform;
                groundTransform.setIdentity();
                groundTransform.setOrigin(btVector3(floor_tile.x, floor_tile.y + 0.1f, floor_tile.z)); // +0.1f for half height of the box (0.2f / 2)

                // 3. Set mass to 0 for a static object (immovable).
                btScalar mass(0.0);
                // Static objects have zero inertia
                btVector3 localInertia(0, 0, 0); 

                // 4. Create the motion state and rigid body, then add to the physics world.
                btDefaultMotionState* myMotionState = new btDefaultMotionState(groundTransform);
                motionStates.push_back(myMotionState); // Store for cleanup

                btRigidBody::btRigidBodyConstructionInfo rbInfo(mass, myMotionState, groundShape, localInertia);
                btRigidBody* body = new btRigidBody(rbInfo);
                rigidBodies.push_back(body); // Store for cleanup

                this->physicsWorld->addRigidBody(body); // Add to the physics simulation
            }
        }
    }
}

const std::vector<Brick>& World::GetBricks() const { 
    return bricks; 
}