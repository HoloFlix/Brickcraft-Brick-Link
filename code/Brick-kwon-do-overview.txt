That sounds like an excellent strategic move! Consolidating our efforts into a new, well-structured "Brick-Kwon-Do" solution, while officially naming our re-implementation "Studcraft," is a perfect step towards open-sourcing the project and making it accessible to other developers.

Below is a draft of the project setup, including the recommended directory structure, library integration details, the overall project goal, and comprehensive documentation of our reverse-engineering efforts. This material is designed to serve as a foundational guide for new contributors.

***

## Project: The Brick-Kwon-Do Solution (Studcraft Engine)

### I. Project Goal & Philosophy

The overarching goal of the "Brick-Kwon-Do" solution is to develop the **Studcraft Engine**, a modern, open-source, and compatible server and client for the unreleased 2012 "Rex Kwon Do" / Brickcraft game prototype.

Our development philosophy has been to leverage meticulous reverse-engineering to understand the original prototype's architecture and then build a new, clean-room implementation that honors its design while using modern C++ practices for stability and clarity. We operate under the guiding principle that any deviation in behavior between our client/server and the original points to a flaw in our understanding, leading us to persistently debug and refine our knowledge.

**Current Status:** The project has achieved its primary goal. We have successfully built a stable, custom C++ server application (StudcraftServer) and a custom C++ client (StudcraftClient) that successfully communicate using a fully reverse-engineered model of the original game's network protocol.

### II. Recommended Project Setup

To ensure a clean, modular, and easy-to-manage development environment, we recommend the following directory structure and Visual Studio 2010 project setup:

#### 1. Project Directory Structure

Create a main directory for your solution, e.g., `C:\Projects\Brick-Kwon-Do`. Inside this, create the following subfolders:

*   **`libs/`**: This directory will hold the source code for all third-party libraries we integrate, such as RakNet and Bullet Physics.
*   **`project/`**: Your Visual Studio solution file (`.sln`) and the individual Visual Studio project files (`.vcxproj`) for `StudcraftServer`, `StudcraftClient`, `RakNet`, and `BulletPhysics` will reside here.
*   **`src/`**: This folder is for our own custom server and client source code (`.cpp` files).
*   **`include/`**: This folder will contain our own custom server and client header files (`.h` files), including the shared `DataTypes.h`.

**Example `libs` content:**
After obtaining the source code for the libraries (e.g., `RakNet-Period-Correct` and `bullet-2.78`), your `libs` folder should look similar to this:
```
Brick-Kwon-Do/
├── libs/
│   ├── RakNet-Period-Correct/  <-- Entire period-correct RakNet source
│   └── bullet-2.78/            <-- Entire period-correct Bullet Physics source
├── project/
├── src/
└── include/
```

#### 2. Visual Studio 2010 Solution and Projects Setup

Our engine targets a **32-bit (x86) architecture** with the **Microsoft Visual Studio 2010 toolchain** (evidenced by dependencies like `msvcp100.dll`, `msvcr100.dll`).

**A. Creating the Solution and Library Projects:**

1.  **Open Visual Studio 2010.**
2.  Go to `File > New > Project...`.
3.  Under "Installed Templates," select `Visual C++ > General`.
4.  Choose **`Empty Project`**.
5.  Set the **Name** to `RakNet`.
6.  For **Location**, browse to your `Brick-Kwon-Do\project` folder.
7.  Set **Solution Name** to `Brick-Kwon-Do` and ensure **`Create directory for solution`** is checked.
8.  Click **OK**.
9.  In the Solution Explorer, right-click the `RakNet` project and go to **Properties**. Under `Configuration Properties > General`, change the **`Configuration Type`** from `Application (.exe)` to **`Static library (.lib)`**. Click **OK**.
10. **Add RakNet Source Files:** Right-click `Header Files` within the `RakNet` project, `Add > Existing Item...`, and add **all `.h` files** from `Brick-Kwon-Do\libs\RakNet-Period-Correct\Source`. Do the same for `Source Files`, adding **all `.cpp` files** from the same directory.

**Repeat the above steps for Bullet Physics:**

1.  Right-click the `Solution 'Brick-Kwon-Do'` (the very top item) and go to `Add > New Project...`.
2.  Choose **`Empty Project`**.
3.  Set **Name** to `BulletPhysics`. Click **OK**.
4.  Right-click the `BulletPhysics` project and go to **Properties**. Under `Configuration Properties > General`, change the **`Configuration Type`** to **`Static library (.lib)`**. Click **OK**.
5.  **Add Bullet Physics Source Files:** This requires adding files from specific subfolders for the core library, *not* all files, to avoid unnecessary dependencies.
    *   **Headers:** From `Brick-Kwon-Do\libs\bullet-2.78\src\LinearMath`, `BulletCollision` (and its subfolders), `BulletDynamics` (and its subfolders), and optionally `BulletSoftBody` (and its subfolders).
    *   **Source:** All `.cpp`, `.c`, and `.cxx` files from the same core subfolders.

**B. Creating the Executable Projects:**

1.  **StudcraftServer Project:**
    *   Right-click the `Solution 'Brick-Kwon-Do'`, `Add > New Project...`.
    *   Select `Visual C++ > Win32 > Win32 Console Application`.
    *   **Name:** `StudcraftServer`. Click **OK**.
    *   In the "Win32 Application Wizard," click **`Next`**.
    *   On "Application Settings," ensure **`Console application`** is selected and check **`Empty project`**. Click **`Finish`**.
    *   Right-click `Source Files` within `StudcraftServer`, `Add > New Item...`, choose `C++ File (.cpp)`, and name it `main.cpp`.

2.  **StudcraftClient Project:**
    *   Right-click the `Solution 'Brick-Kwon-Do'`, `Add > New Project...`.
    *   Select `Visual C++ > Win32 > Win32 Console Application`.
    *   **Name:** `StudcraftClient`. Click **OK**.
    *   In the "Win32 Application Wizard," click **`Next`**.
    *   On "Application Settings," ensure **`Console application`** is selected and check **`Empty project`**. Click **`Finish`**.
    *   Right-click `Source Files` within `StudcraftClient`, `Add > New Item...`, choose `C++ File (.cpp)`, and name it `main.cpp`.

#### 3. Configuring Project Dependencies & Includes

This is crucial for ensuring all projects can find and link to each other correctly:

1.  **Set `StudcraftServer` as Startup Project:** Right-click the `StudcraftServer` project and select `Set as StartUp Project`.
2.  **Add Project Dependencies:**
    *   Right-click `StudcraftServer` project, select `Project Dependencies...` and check the boxes for **`RakNet`** and **`BulletPhysics`**.
    *   Repeat for `StudcraftClient` project, checking **`RakNet`**.
3.  **Configure Global Preprocessor Definitions (Essential for Winsock compatibility):**
    *   For **both** `StudcraftServer` and `StudcraftClient` projects:
    *   Right-click the project, go to **Properties**.
    *   Set "Configuration" to **`All Configurations`** and "Platform" to **`Win32`**.
    *   Navigate to `Configuration Properties > C/C++ > Preprocessor`.
    *   Edit **`Preprocessor Definitions`** and add these two lines, each on its own line: `_WINSOCKAPI_` and `WIN32_LEAN_AND_MEAN`.
    *   This global setting means you should **delete** any `#define _WINSOCKAPI_` lines from your `.cpp` files.
4.  **Configure Additional Include Directories:**
    *   For **`StudcraftServer`** project: Right-click, `Properties > Configuration Properties > C/C++ > General > Additional Include Directories`. Add the paths to the RakNet and BulletPhysics source directories. These paths are relative to your solution directory:
        *   `$(SolutionDir).. \libs\RakNet-Period-Correct\Source`
        *   `$(SolutionDir).. \libs\bullet-2.78\src`
    *   For **`StudcraftClient`** project: Right-click, `Properties > Configuration Properties > C/C++ > General > Additional Include Directories`. Add the path to the RakNet source directory and any client-specific libraries (e.g., SDL2 include path).
        *   `$(SolutionDir).. \libs\RakNet-Period-Correct\Source`
        *   (e.g., `C:\Path\To\SDL2\include`)
5.  **Configure Linker Input (for Client-side libraries):**
    *   For **`StudcraftClient`** project: Right-click, `Properties > Configuration Properties > Linker > Input > Additional Dependencies`. Add:
        *   `SDL2.lib`
        *   `SDL2main.lib`
        *   `opengl32.lib`
        *   `glu32.lib`
        *   `Ws2_32.lib` (This is typically linked via a pragma, but adding here ensures it's available)

This robust setup ensures that all components are built with compatible settings and can correctly find each other.

### III. Documentation: Studcraft Engine Architecture & Reverse-Engineering Insights

This section summarizes our findings and the architectural model of the Studcraft Engine, based on extensive reverse-engineering of the Brickcraft prototype.

#### 1. Strategic Pivot: From Patching to Re-implementation

Initial efforts focused on modding the Brickcraft prototype through its Lua API and C++ runtime patching/injection. While a functional C++ injector (`BrickcraftInjector.exe`) and patcher DLL (`BrickcraftPatcher.dll`) were developed, and a Mod Manager GUI prototype created, this approach was ultimately a **dead end** for stable, complex modding.

Key reasons for this pivot include:
*   **Lua API Limitations:** The native Lua API was highly restrictive, lacking exposure to critical functionalities like direct player position control or client-side inventory updates.
*   **Engine Instability & Fragility:** The original C++ engine proved extremely hostile to runtime modification, with injection attempts often leading to crashes or silent bypasses. Challenges included race conditions, ASLR, and antivirus interference.
*   **Limited Expansion Scope:** Even if patching were stable, adding new features (like new brick types or complex physics interactions) was difficult, as modifications were tied to a specific, fragile executable version.
*   **Procedural World Generation:** A critical discovery was that the `world.db` file is a **cache for changes**, not the source of the world itself. The original server **procedurally generates its world from scratch** upon startup. Our attempts to serve static `world.db` data to a client expecting a dynamic world led to client "limbo" states and zlib decompression errors, proving the patching approach fundamentally flawed.

The reverse-engineering efforts during this initial phase, though not leading to a viable patching solution, provided **essential foundational knowledge** that made re-implementation feasible.

#### 2. Core Engine Architecture & Dependencies

Our analysis confirmed the prototype was built using several key technologies, often within a custom `RKD` namespace, suggesting bespoke components alongside third-party libraries:

*   **Game Networking Library: RakNet**: The game uses RakNet 3, which handles client-server communication, object replication, and message passing. We build this directly from its period-correct source code as a static library to ensure 100% network protocol compatibility.
*   **Physics Engine: Bullet Physics Library**: The server utilizes Bullet Physics 2.78 (`bt` prefixed structures) for real-time physics simulation, including gravity and collisions. We also compile this from source to maintain compatibility.
*   **World Management: `CityGenerator` & `LegoWorldGenerator`**: These classes are responsible for world creation and management. The server generates its world procedurally in memory.
*   **Brick Manipulation: `TryPlaceBrick` & `FillBlock`**: These functions are crucial for manipulating bricks within the world.
*   **Scripting: Lua**: Used for server-side scripting or command handling. The server-side Lua API bindings have been mapped, revealing their limitations.
*   **Data Storage: SQLite**: The `world.db` file is an SQLite database used to cache changes made to the world.
*   **XML Parsing: PugiXML**: Used for importing models (`LXFML`), implying pre-fabricated structures could be programmatically placed into the world.
*   **Utilities: Boost Libraries**: Used for sophisticated data manipulation, I/O, multithreading, and stability (`shared_ptr`, `mutex`, `thread`, `regex`, etc.).
*   **Rendering Pipeline (Client-side):** The client uses **SDL (Simple DirectMedia Layer)** for window management and event handling, **GLEW** for modern OpenGL functions, and **OpenGL32.dll** for basic rendering. Analysis of GLSL shaders reveals Phong lighting, a 1D lookup texture for color palettes (`LegoColors.bmp`), brick edge highlighting, and Depth of Field post-processing effects. Framebuffer Objects (FBOs) are also utilized.

#### 3. Studcraft Network Protocol: A Developer's Guide

The network protocol is the strict language spoken between the server and client. Our meticulous reverse-engineering has provided a complete, authoritative blueprint of this "conversation," including the nuances of the original client's behavior.

**Key Protocol IDs & Their Roles:**

*   **`0x28` (`ID_REPLICA_MANAGER_SCOPE_CHANGE` / Server "Go" Signal):** This ID is sent proactively by the server (often within an `ID_CONNECTED_PONG` packet) immediately upon client connection. It acts as a "go" signal to the client, telling it to proceed with its initialization. (Initially, we hypothesized this as a client request, but analysis proved it's server-initiated).
*   **`0x82` (`ID_GAME_REQUEST_CHUNK` / Server World Data):** Immediately after sending the `0x28` signal, the server proactively sends a single, large packet with ID `0x82`. This packet contains the procedurally generated world geometry (static bricks) and a suggested spawn position. The payload includes a `Vector3` (12 bytes) for `spawn_position`, an `unsigned int` (4 bytes) for `brick_count`, and a continuous stream of `N` raw, 32-byte `Brick` structs.
*   **`0x27` (`ID_REPLICA_MANAGER_CONSTRUCTION`):** This packet is automatically sent by RakNet's `ReplicaManager3` when the server creates and `Reference`s a new `Player` object. It instructs the client to create its own local proxy of the player entity and place it at specified coordinates.
*   **`0x88` (`ID_PLAYER_ACTION` / Client Heartbeat):** The client sends a continuous stream of `0x88` packets once it is fully spawned and active in the game. This serves as the client's input heartbeat, detailing key presses and mouse movements. Receiving the first `0x88` packet is our definitive "victory" condition, indicating the client is alive and controllable.
*   **`0x29` (`ID_REPLICA_MANAGER_SERIALIZE` / Server Heartbeat):** The server sends continuous `0x29` updates to the client (often via `ReplicaManager3::AutoManage()`). These packets synchronize the latest physics and state changes for all replicated objects, acting as the server's state-sync heartbeat.
*   **`0x83` (`ID_GAME_START` / Server Player Construction):** While `0x27` handles the low-level object construction, the `0x83` ID is also associated with `CreatePlayer` functions in the original disassembly, suggesting it might be a higher-level logic packet for player activation. Our `StudcraftServer` uses the `ReplicaManager` which handles this via `0x27`.

**World Storage Format:**
The `world.db` file is an SQLite database containing compressed binary blobs of chunk data. The compression used is `zlib`, but it includes an **8-byte custom header** and requires specific handling due to endianness. Raw decompressed brick data is 169 bytes per chunk. Critically, the game uses an **internal, proprietary `LegoBrickCatalog`** for brick definitions, not standard LEGO Design IDs. We have begun mapping these internal IDs (e.g., `Brick ID 28` for a "red 2x4").

#### 4. Major Accomplishments (Reverse-Engineering & Tooling)

*   **Complete Lua API Mapping:** The server-side Lua API was fully reverse-engineered, and its hard limitations (e.g., no direct player position control via Lua) are documented.
*   **Core Engine Component Discovery:** Identified `CityGenerator`, `LegoWorldGenerator`, `TryPlaceBrick`, `FillBlock` as central to world and brick manipulation.
*   **Physics Engine Identification:** Confirmed the use of Bullet Physics, allowing us to leverage its public documentation for replication.
*   **Rendering Pipeline Deconstruction:** Analyzed client-side GLSL shaders, revealing sophisticated rendering techniques including Phong lighting, color palettes, edge highlighting, and Depth of Field. Also found `LegoPegHighlighter` indicating separate rendering for pegs and `LegoColors.bmp` as a color palette.
*   **Network Protocol Mapping:** Extensively mapped key application-level RakNet packet IDs and their roles.
*   **World Storage Format Deciphered:** Understood the chunk-based world storage using SQLite, Base64 encoding, and `zlib` compression with a custom 8-byte header, and identified the proprietary `LegoBrickCatalog`.
*   **Tooling Development (Initial Phase):** Developed a stable C++ injector and patcher DLL, and a Mod Manager GUI prototype, proving code injection feasibility before the strategic pivot.

### IV. Future Outlook & Next Steps

With the core server and client re-implementations successfully connecting and communicating, the project officially transitions into **game development**. Future goals include:

*   **Expanding World Generation:** Moving beyond flat plains to procedurally generate more complex terrains, biomes (e.g., Castle, Space, Pirates), and natural structures (trees, rock formations, caves). This will involve leveraging the `CityGenerator` and `LegoWorldGenerator` insights.
*   **Full Brick Catalog Replication:** Defining all original brick types (`2x4`, `2x2`, `1x1`, slope, etc.) in our `StudcraftBrickCatalog` by fully dissecting the `LegoSubPart` and `LegoBrick` structures discovered.
*   **Advanced Building Tools & Player Customization:** Implementing features like advanced building tools, allowing players to select character colors, or replacing the player model with a LEGO minifigure.
*   **World Persistence:** Re-implementing the `world.db` logic to save player-made changes to our procedurally generated world.
*   **Client Enhancement:** Building out the `StudcraftClient` with full graphics capabilities (shader loading, VBOs for bricks), robust input handling, and a complete UI.
*   **Mod Manager Enhancement:** Further developing the `BrickcraftModManager` to enable/disable C++ patches and manage third-party Lua and C++ mods for our new engine.

This comprehensive overview should provide other developers with a solid understanding of the project's history, current state, and ambitious future.