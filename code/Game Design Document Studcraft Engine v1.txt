Game Design Document: Studcraft Engine (v1.0)
1. Project Overview
• Project Name: Studcraft (formerly "Brickcraft Phoenix Protocol," or "Brickcraft Restoration Project").
• Core Objective: To build a modern, open-source, and compatible server and client for the unreleased 2012 "Rex Kwon Do" / Brickcraft game prototype. The aim is to overcome the original prototype's modding limitations and create a playable, expandable experience.
• Current Status: SUCCESS. We have successfully reverse-engineered the original protocol and built a new, stable, custom C++ server (StudcraftServer) and client (StudcraftClient) that establish a full connection, generate a procedural world, replicate a player object, and allow for real-time player control (movement and camera look). The reverse-engineering phase is complete.
2. Game Concept
• Genre: Sandbox, Creative Building, Exploration, Multiplayer.
• Core Inspiration: A fusion of LEGO-style brick building with Minecraft-like world generation and gameplay.
• Original Vision: The prototype's initial concept involved creating a Lego brick world with biomes based on different Lego sets.
• Player Avatar: The default player character, sometimes referred to as "tofuman/character" in forums, appears as four stacked bricks with a red brick as the head/camera.
3. Core Gameplay Mechanics (Current & Future)
3.1. World Generation & Environment
• Current:
    ◦ The StudcraftServer can procedurally generate a simple, flat world (e.g., a 16x16 or 50x50 plane of tiles) entirely from C++ code.
    ◦ The server is the authoritative source for world generation; the original world.db is confirmed to be a cache for changes made by players, not the source of the world itself.
    ◦ The client successfully receives, deserializes, and renders this procedurally generated world.
• Future Goals:
    ◦ Improved World Generation: Expand upon the identified CityGenerator and LegoWorldGenerator classes to create more varied and interesting landscapes.
    ◦ Biomes: Implement distinct biomes based on classic LEGO themes like Castle, Space, or Pirates, as was the original intent.
    ◦ Varied Terrain Height: Move beyond simple flat planes to allow for more dramatic landscapes and potentially exceed the original 80-brick height limit.
    ◦ Natural Structures: Procedurally generate simple structures like trees (using test.lxfml as a starting point), rock formations, and caves.
    ◦ LXFML Import: Re-implement the LXFMLImporter using the PugiXML library to allow loading complex pre-fabricated LEGO structures into the world.
3.2. Building & Interaction
• Current: While the server can generate a world, direct in-game placing and breaking of bricks by the player is not yet implemented.
• Future Goals:
    ◦ Place and Break Bricks: Implement server-side logic to handle player requests for placing and breaking bricks. This will involve modifying the server's in-memory world representation (std::vector<Brick>).
    ◦ Expanded Brick Library: Introduce a wider range of brick types beyond the initial 2x4 and 2x2. The prototype has a confirmed 6 types (2x4, 2x2, 2x1, 1x1, 2x1 slope). We have the fundamental understanding of how to create any brick type by defining its constituent LegoSubParts and building a StudcraftBrickCatalog.
    ◦ Brick Properties: Replicate features like pegs on top of bricks, which are rendered via a LegoPegHighlighter on the client.
    ◦ World Persistence: Implement world.db logic as a destination for saving player-made changes to the procedurally generated world, rather than as the source of the world itself.
3.3. Player Movement & Control
• Current:
    ◦ Players successfully spawn at a physics-aware position in the world.
    ◦ Full WASD movement and mouse-look control is implemented, with client input being sent to the server, processed by the server's physics simulation, and replicated back to the client.
• Future Goals:
    ◦ Character Customization: Allow players to select their character color or replace the default "tofuman" model with a LEGO minifigure.
    ◦ Player State: Implement more complex player states (e.g., crouching, swimming, climbing) based on client input and server physics.
4. Technical Architecture: The Studcraft Engine
The Studcraft Engine is a robust client-server application built in C++ within a single Visual Studio 2010 solution, ensuring period-correct compilation for compatibility with the original prototype's toolchain and expected runtime libraries (msvcp100.dll, msvcr100.dll).
4.1. Core Components
• RakNet (Static Library): A period-correct build of the RakNet 3 networking library, compiled directly from our own source tree. This is crucial for 100% network protocol compatibility. It handles low-level connections and high-level object replication.
• BulletPhysics (Static Library): A period-correct build of the Bullet Physics 2.78 library, also compiled from source. This provides the authoritative, real-time physics simulation that governs all dynamic objects, including players. The server is the authoritative source for all physics calculations.
• StudcraftServer (Executable): Our new, custom-built server application. It acts as the central orchestrator, managing the main application loop, owning all other systems, and handling network message dispatch.
• StudcraftClient (Executable): Our new, custom-built client application. It uses SDL2 and OpenGL for rendering, handles user input, and communicates with the server.
4.2. Network Protocol (Reverse-Engineered & Implemented)
The communication between the StudcraftServer and StudcraftClient adheres to a meticulously reverse-engineered protocol, which is a strict sequence of events.
• Connection & Handshake: Standard RakNet connection is established upon client launch.
• World Transmission (ID_SERVER_WORLD_DATA = 0x82): Immediately upon client connection, the server proactively sends a single, large packet containing the procedurally generated world geometry (including a Vector3 for suggested spawn_position and an unsigned int for brick_count, followed by a continuous stream of raw 32-byte Brick structs).
• Player Construction (ID_REPLICA_MANAGER_CONSTRUCTION = 0x27): Immediately after sending the world data, the server creates a Player object (which inherits from RakNet::Replica3) and calls replicaManager->Reference(playerObject). The ReplicaManager3 automatically sends the 0x27 construction packet to the client, instructing it to create its local player entity.
• Client Activation & Victory Condition: Once the client receives both the world geometry (0x82) and its player entity (0x27), its state machine is fully satisfied, and it begins sending a continuous stream of player input packets. The server's receipt of its first 0x88 packet (ID_PLAYER_ACTION) is the definitive "victory" condition, signifying a fully spawned, active, and controllable client.
• Gameplay Loop (Client to Server): The client sends 0x88 packets continuously, containing a PlayerInput struct detailing keyboard presses (WASD, jump) and mouse movement (delta_yaw, delta_pitch).
• Server Processing: The server receives 0x88 packets, parses the input, and applies forces/rotations to the corresponding player's btRigidBody within its authoritative physics simulation.
• Server to Client (Replication & Heartbeat): The ReplicaManager3 automatically detects changes in replicated objects' states (like the player's btTransform) and serializes these updates. These are sent to the client as ID_REPLICA_MANAGER_SERIALIZE (0x29) packets, acting as both a server heartbeat and state synchronization mechanism.
• Client Rendering: The client receives these ReplicaManager serialization packets, deserializes the new btTransform, and updates the position of its local player model, causing it to move on screen.
4.3. World Data & Brick Structure
• World Storage Format: The game uses a chunk-based world storage. The raw brick data is structured as 169 bytes per chunk, which contain a 3D array of block IDs. zlib compression (with an 8-byte custom header) is used for world data.
• Proprietary Brick IDs: The engine uses its own internal, proprietary LegoBrickCatalog for brick definitions, not official LEGO Design IDs. A Brick struct has been reverse-engineered with specific coordinates, a proprietary brick_id, color_id, and rotation data.
• Brick Construction: Bricks are composed of fundamental LegoSubParts, each with a type (TYPE_BLOCK, TYPE_TOPSLOPE2), position, rotation, and connectivity. The brick_id is an index into a global array defining these sub-parts.
4.4. Rendering Pipeline
• Client-Side Rendering: The client uses SDL (Simple DirectMedia Layer) and OpenGL for rendering.
• Shaders: The engine employs a sophisticated shader-based pipeline (GLSL shaders) with features like Phong lighting, a 1D lookup texture for color palettes (LegoColors.bmp), edge highlighting, and a Depth of Field (DoF) post-processing effect.
• Pegi Highlighting: A dedicated LegoPegHighlighter class is responsible for rendering pegs on nearby bricks, which are culled at a distance to optimize performance.
• Camera: The client's camera is tied to the player's position and orientation, updated by the server's physics replication.
5. Future Development Roadmap
5.1. World Generation & Terrain
• Implement CityGenerator and LegoWorldGenerator logic to create more diverse and complex terrain (hills, valleys).
• Integrate LXFMLImporter to support pre-fabricated structures and models from .lxfml files.
• Further develop biome implementation based on LEGO themes (Castle, Space, Pirates).
• Expand terrain height and procedurally generate natural structures (trees, rock formations, caves).
5.2. Expanded Brick System
• Implement the full set of original brick types (e.g., 2x4, 2x2, 2x1, 1x1, 2x1 slope) and their corresponding LegoSubPart definitions.
• Create a robust StudcraftBrickCatalog to define and manage new brick types, colors, and properties, enabling infinite creative freedom for building.
• Develop client-side rendering for complex brick models, moving beyond simple cubes to use Vertex Buffer Objects (VBOs) and proper shaders.
5.3. Player & Interaction
• Implement Place Brick and Break Brick functionality, including client-side raycasting and server-side validation and world modification.
• Allow player character customization, such as selecting brick color or replacing the "tofuman" model with a LEGO minifigure.
• Refine player physics and movement to include more nuanced actions (e.g., jumping, falling, ground checks).
5.4. Modding & Tools
• Further develop the BrickcraftModManager (now StudcraftModManager) with a user-friendly GUI (Dear ImGui).
• Enable users to easily manage and load third-party Lua and C++ mods, as well as enable/disable specific patches.
• Refine the Lua/C++ bridge to allow dynamic unlocking of C++ functionality for Lua scripts.
5.5. Graphics & User Interface
• Implement window resizing for the StudcraftClient.
• Develop a more comprehensive HUD and UI elements, potentially utilizing the client's C++ UI control logic.
• Refine existing shader implementations and explore new visual effects to enhance the game's appearance.