
// File: DataTypes.h
--------------------------------------------------------------------------------
#pragma once

// Must include RakNetTypes.h for RakNet::RakNetGUID
#include "RakNetTypes.h" // Needed for RakNet::RakNetGUID
#include "btBulletCollisionCommon.h" // Needed for btQuaternion

#pragma pack(push, 1)
struct Brick { char u[3]; float x, y, z; int id; int c_id; char r[9]; };
#pragma pack(pop)

struct Vector3 { float x,y,z; };

struct PlayerInput {
    bool is_forward_pressed;
    bool is_left_pressed;
    bool is_backward_pressed;
    bool is_right_pressed;
    bool is_jump_pressed;
    float delta_yaw;
    float delta_pitch;
};

// Struct to hold player state for network transmission
struct PlayerState {
    RakNet::RakNetGUID guid;
    Vector3 position;
	btQuaternion rotation;
};
--------------------------------------------------------------------------------

// File: PhysicsWorld.cpp
--------------------------------------------------------------------------------
#include "PhysicsWorld.h"

PhysicsWorld::PhysicsWorld() {
    collisionConfiguration = new btDefaultCollisionConfiguration();
    dispatcher = new btCollisionDispatcher(collisionConfiguration);
    overlappingPairCache = new btDbvtBroadphase();
    solver = new btSequentialImpulseConstraintSolver();
    dynamicsWorld = new btDiscreteDynamicsWorld(dispatcher, overlappingPairCache, solver, collisionConfiguration);
    dynamicsWorld->setGravity(btVector3(0, -9.81f, 0));
}

PhysicsWorld::~PhysicsWorld() {
    // With raw pointers, we must manually delete in the reverse order of creation.
    // Clean up all collision objects from the dynamics world before deleting the world itself
    if (dynamicsWorld) {
        for (int i = dynamicsWorld->getNumCollisionObjects() - 1; i >= 0; i--) {
            btCollisionObject* obj = dynamicsWorld->getCollisionObjectArray()[i];
            btRigidBody* body = btRigidBody::upcast(obj);
            if (body && body->getMotionState()) {
                delete body->getMotionState();
            }
            dynamicsWorld->removeCollisionObject(obj);
            delete obj; // Delete the collision object itself
        }
    }

    delete dynamicsWorld;
    dynamicsWorld = nullptr; // Set to nullptr after deletion
    delete solver;
    solver = nullptr;
    delete overlappingPairCache;
    overlappingPairCache = nullptr;
    delete dispatcher;
    dispatcher = nullptr;
    delete collisionConfiguration;
    collisionConfiguration = nullptr;
}

void PhysicsWorld::Step(float dt) {
    if (dynamicsWorld) { // Add a null check for safety
        dynamicsWorld->stepSimulation(dt, 10); // up to 10 substeps per frame
    }
}
--------------------------------------------------------------------------------

// File: PhysicsWorld.h
--------------------------------------------------------------------------------
#pragma once
#include <btBulletDynamicsCommon.h>
// #include <memory> // REMOVED: No longer using std::unique_ptr for dynamicsWorld

class PhysicsWorld {
public:
    PhysicsWorld();
    ~PhysicsWorld();

    void Step(float dt);

    // Changed to return raw pointer directly, as dynamicsWorld is now a raw pointer
    btDiscreteDynamicsWorld* GetWorld() { return dynamicsWorld; }

private:
    btDefaultCollisionConfiguration* collisionConfiguration;
    btCollisionDispatcher* dispatcher;
    btBroadphaseInterface* overlappingPairCache;
    btSequentialImpulseConstraintSolver* solver;
    // Changed from std::unique_ptr to raw pointer
    btDiscreteDynamicsWorld* dynamicsWorld;
};
--------------------------------------------------------------------------------

// File: Player.cpp
--------------------------------------------------------------------------------
#include "Player.h"
#include <iostream>
#define _USE_MATH_DEFINES
#include <math.h>

// --- In the Player::Player() constructor, change `m_physics(nullptr)` to: ---
// Initialize m_physics to NULL and m_networkIDManager to NULL
Player::Player() : m_physics(NULL), guid(RakNet::UNASSIGNED_RAKNET_GUID), m_networkIDManager(NULL) {}

// --- In the Player::~Player() destructor, ADD cleanup logic: ---
Player::~Player() {
    delete m_physics; // This will call the PlayerPhysics destructor
    m_physics = NULL;
    // Note: m_networkIDManager is typically managed externally (e.g., by Server),
    // so we don't delete it here.
}

// --- In Player::CreatePhysics, REPLACE `m_physics = std::make_unique...` with: ---
void Player::CreatePhysics(btDiscreteDynamicsWorld* world, float x, float y, float z) {
    m_physics = new PlayerPhysics(world, x, y, z);
}

// THIS IS THE PRIMARY BUG FIX
void Player::ProcessInput(const PlayerInput& input) {
    if (!m_physics || !m_physics->GetBody()) return;

    btRigidBody* body = m_physics->GetBody();
    btTransform t;
    body->getMotionState()->getWorldTransform(t);

    // 1. Apply YAW rotation from mouse look. PITCH is now ignored here.
    if (input.delta_yaw != 0) {
        btQuaternion rotation = t.getRotation();
        // We only apply the yaw rotation around the WORLD's Y-axis (0,1,0).
        btQuaternion yaw_rotation(btVector3(0, 1, 0), input.delta_yaw * -0.005f);
        t.setRotation(rotation * yaw_rotation);
        body->getMotionState()->setWorldTransform(t); // Update transform for rotation
    }

    // 2. Calculate movement direction. This code is already correct because it
    //    bases its direction on the physics body's transform, which we just updated.
    btVector3 move_direction(0, 0, 0);
    // Get forward and right vectors relative to the player's current orientation
    // Ensure they are horizontal by setting Y to 0 and re-normalizing.
    btVector3 forward = t.getBasis().getColumn(2); forward.setY(0); forward.normalize();
    btVector3 right   = t.getBasis().getColumn(0); right.setY(0);   right.normalize();

    if (input.is_forward_pressed)  move_direction -= forward; // Move along the negative forward vector
    if (input.is_backward_pressed) move_direction += forward; // Move along the positive forward vector
    if (input.is_left_pressed)     move_direction -= right;   // Move along the negative right vector (left)
    if (input.is_right_pressed)    move_direction += right;   // Move along the positive right vector (right)

    // --- The rest of the function (setting velocity, jump, activate) is perfect and needs no changes. ---
    // 3. Set velocity
    // Preserve the current vertical velocity (for gravity/jumping)
    float current_y_velocity = body->getLinearVelocity().y();
    if (move_direction.length2() > 0.0f) { // Only apply horizontal velocity if there's input
        move_direction.normalize();
        body->setLinearVelocity(move_direction * 5.f + btVector3(0, current_y_velocity, 0));
    } else {
        // If no movement keys are pressed, only preserve vertical velocity
        body->setLinearVelocity(btVector3(0, current_y_velocity, 0));
    }

    // 4. Handle jumping
    // A raycast downwards is a better "isGrounded" check, but this is fine for now
    // Prevents "double jumps" by checking if the player is near the ground.
    if (input.is_jump_pressed && (body->getCenterOfMassPosition().y() < 1.8f)) {
        body->applyCentralImpulse(btVector3(0, 7.f, 0)); // Apply an upward impulse
    }

    // 5. Ensure the body is active so it doesn't fall asleep
    // Bullet physics bodies can "sleep" to save CPU if they aren't moving.
    // Activating it ensures it responds to impulses and continuous velocity changes.
    body->activate(true);
}

// Player::GetPhysics() now returns the raw pointer directly
PlayerPhysics* Player::GetPhysics() const { return m_physics; }
RakNet::RakNetGUID Player::GetGUID() const { return guid; }
void Player::SetGUID(RakNet::RakNetGUID g) { this->guid = g; }

// ADDED: Implementation for SetNetworkIDManager
void Player::SetNetworkIDManager(RakNet::NetworkIDManager* networkIDManager) {
    m_networkIDManager = networkIDManager;
    // Removed problematic line: m_networkIDManager->SetNetworkID(this, guid.g);
    // This line is typically for ReplicaManager, not direct manual NetworkID assignment.
    // For your current manual replication, simply storing the manager is sufficient.
}
--------------------------------------------------------------------------------

// File: Player.h
--------------------------------------------------------------------------------
#pragma once

#include "DataTypes.h"
#include "RakNetTypes.h"
#include "PlayerPhysics.h" // NEW
#include "NetworkIDManager.h" // ADDED: Required for SetNetworkIDManager

// #include <memory>          // REMOVED: No longer using std::unique_ptr for m_physics

class Player {
public:
    Player();
    ~Player();

    void CreatePhysics(btDiscreteDynamicsWorld* world, float x, float y, float z);
    void ProcessInput(const PlayerInput& input);

    PlayerPhysics* GetPhysics() const; // Renamed for clarity
    RakNet::RakNetGUID GetGUID() const;
    void SetGUID(RakNet::RakNetGUID g);

    // ADDED: Declaration for SetNetworkIDManager
    void SetNetworkIDManager(RakNet::NetworkIDManager* networkIDManager);

private:
    PlayerPhysics* m_physics; // Raw pointer
    RakNet::RakNetGUID guid;
    RakNet::NetworkIDManager* m_networkIDManager; // ADDED: To store the NetworkIDManager
};
--------------------------------------------------------------------------------

// File: PlayerPhysics.cpp
--------------------------------------------------------------------------------
#include "PlayerPhysics.h"

PlayerPhysics::PlayerPhysics(btDiscreteDynamicsWorld* world, float x, float y, float z)
    : world(world) {
    // Capsule is best for "character" movement
    shape = new btCapsuleShape(0.4f, 1.2f); // radius, height
    btTransform startTransform;
    startTransform.setIdentity();
    startTransform.setOrigin(btVector3(x, y, z));
    motionState = new btDefaultMotionState(startTransform);

    btScalar mass = 80.0f;
    btVector3 inertia(0, 0, 0);
    shape->calculateLocalInertia(mass, inertia);

    btRigidBody::btRigidBodyConstructionInfo rbInfo(mass, motionState, shape, inertia);
    body = new btRigidBody(rbInfo);
    body->setAngularFactor(0); // No tipping over!

    world->addRigidBody(body);
}

PlayerPhysics::~PlayerPhysics() {
    world->removeRigidBody(body);
    delete body;
    delete motionState;
    delete shape;
}
--------------------------------------------------------------------------------

// File: PlayerPhysics.h
--------------------------------------------------------------------------------
#pragma once
#include <btBulletDynamicsCommon.h>

class PlayerPhysics {
public:
    PlayerPhysics(btDiscreteDynamicsWorld* world, float x, float y, float z);
    ~PlayerPhysics();

    btRigidBody* GetBody() { return body; }

private:
    btCollisionShape* shape;
    btDefaultMotionState* motionState;
    btRigidBody* body;
    btDiscreteDynamicsWorld* world;
};
--------------------------------------------------------------------------------

// File: Server.cpp
--------------------------------------------------------------------------------
#define _WINSOCKAPI_ // ADDED: To resolve C4005 warning
#define _WINSOCK_DEPRECATED_NO_WARNINGS

#include "Server.h"
#include "MessageIdentifiers.h"
#include "BitStream.h"
#include "GetTime.h"
// #include "btBulletDynamicsCommon.h" // No longer needed directly here, PhysicsWorld encapsulates it
#include <iostream>
#include <algorithm> // For std::remove_if
#include <vector>
#include <windows.h> // For Sleep

const unsigned char ID_SERVER_WORLD_DATA = 0x82;
const unsigned char ID_PLAYER_ACTION = 0x88;
const unsigned char ID_PLAYER_STATES = 0x89;
const unsigned char ID_PLAYER_DISCONNECT_NOTIFICATION = 0x90;

// Server class constructor
Server::Server() :
    peer(nullptr),
    networkIdManager(nullptr),
    m_physicsWorld(nullptr), // Initialize raw pointer to nullptr
    world(nullptr) // Initialize world to nullptr FIRST
{
    // NEW: Create the physics world
    m_physicsWorld = new PhysicsWorld();

    // Now that the physics world exists, create the game world,
    // passing it the raw pointer to the dynamicsWorld obtained from PhysicsWorld.
    world = new World(m_physicsWorld->GetWorld());
}

// Server class destructor
Server::~Server() {
    // Clean up players. The Player's destructor will handle its PlayerPhysics cleanup.
    for (size_t i = 0; i < players.size(); ++i) {
        delete players[i]; // This triggers Player's destructor, cleaning up its physics object
    }
    players.clear();

    // Cleanup world (this will now call World::~World() which cleans its physics objects)
    delete world;
    world = nullptr;

    // ADDED: Clean up the physics world (since it's a raw pointer now)
    delete m_physicsWorld;
    m_physicsWorld = nullptr; // Set to nullptr after deletion

    // Cleanup RakNet components
    if (peer) {
        RakNet::RakPeerInterface::DestroyInstance(peer);
        peer = nullptr;
    }
    delete networkIdManager;
    networkIdManager = nullptr;
}

// Server Startup function (Corrected)
void Server::Startup(){
    init_networking();

    world->GenerateSimplePlatform();

    std::cout << "[OK] Startup Complete\n";
}

void Server::init_networking(){
    peer = RakNet::RakPeerInterface::GetInstance();

    networkIdManager = new RakNet::NetworkIDManager();

    RakNet::SocketDescriptor sd(37373,0);
    peer->Startup(10,&sd,1);
    peer->SetMaximumIncomingConnections(10);
}

void Server::Run(){
    RakNet::Packet*p;
    std::cout << "[OK] Running...\n";

    RakNet::TimeMS lastPhysicsTick = RakNet::GetTimeMS();
    const RakNet::TimeMS physicsUpdateInterval = 1000 / 60; // 60 ticks per second

    while(true){
        for(p=peer->Receive();p;peer->DeallocatePacket(p),p=peer->Receive()){
            if(p->length==0)continue;
            unsigned char mID=p->data[0];

            if(mID==ID_NEW_INCOMING_CONNECTION){
                std::cout << "New incoming connection from " << p->systemAddress.ToString() << std::endl;
                send_world(p->systemAddress);
                Player* player = create_player(p->guid);
                players.push_back(player);

            }
            else if(mID==ID_PLAYER_ACTION){
                for(size_t i=0;i<players.size();++i){
                    if(players[i] && players[i]->GetGUID()==p->guid){
                        RakNet::BitStream bs(p->data,p->length,false);
                        bs.IgnoreBytes(1);
                        PlayerInput pi;
                        bs.Read(pi);
                        players[i]->ProcessInput(pi);
                        break;
                    }
                }
            } else if (mID==ID_CONNECTION_LOST||mID==ID_DISCONNECTION_NOTIFICATION){
                std::cout << "Client disconnected: " << p->systemAddress.ToString() << std::endl;
                remove_player(p->guid);
                RakNet::BitStream bs;
                bs.Write(ID_PLAYER_DISCONNECT_NOTIFICATION);
                bs.Write(p->guid);
                peer->Send(&bs, HIGH_PRIORITY, RELIABLE_ORDERED, 0, p->systemAddress, true);
            }
        }

        RakNet::TimeMS currentTime = RakNet::GetTimeMS();
        if (currentTime - lastPhysicsTick >= physicsUpdateInterval) {
            // NEW: Step the physics world using the PhysicsWorld object
            m_physicsWorld->Step(physicsUpdateInterval / 1000.f);
            send_player_states_to_all_clients();
            lastPhysicsTick = currentTime;
        }

        Sleep(15);
    }
}

void Server::send_world(RakNet::SystemAddress addr){
    RakNet::BitStream bs;
    bs.Write((unsigned char)ID_SERVER_WORLD_DATA);

    Vector3 pos;
    pos.x = 0;
    pos.y = 10;
    pos.z = 0;
    bs.Write(pos);

    const std::vector<Brick>&bricks=world->GetBricks();
    bs.Write((unsigned int)bricks.size());

    for(size_t i=0; i<bricks.size();++i){
        bs.Write((char*)&(bricks[i]),sizeof(Brick));
    }
    peer->Send(&bs,HIGH_PRIORITY,RELIABLE_ORDERED,0,addr,false);
}

// --- REPLACE send_player_states_to_all_clients ---
void Server::send_player_states_to_all_clients() {
    if (players.empty()) return;
    RakNet::BitStream bs;
    bs.Write(ID_PLAYER_STATES);
    bs.Write((unsigned int)players.size());

    for (size_t i = 0; i < players.size(); ++i) {
        Player* p = players[i];
        // Get the rigid body from the PlayerPhysics component
        if (p && p->GetPhysics() && p->GetPhysics()->GetBody()) {
            btTransform t;
            p->GetPhysics()->GetBody()->getMotionState()->getWorldTransform(t);
            PlayerState ps;
            ps.guid = p->GetGUID();
            ps.position.x = t.getOrigin().x();
            ps.position.y = t.getOrigin().y();
            ps.position.z = t.getOrigin().z();
            ps.rotation = t.getRotation();
            bs.Write((char*)&ps, sizeof(PlayerState));
        }
    }
    peer->Send(&bs, HIGH_PRIORITY, UNRELIABLE_SEQUENCED, 0, RakNet::UNASSIGNED_SYSTEM_ADDRESS, true);
}

// --- REPLACE create_player ---
Player* Server::create_player(RakNet::RakNetGUID guid) {
    Player* p = new Player();
    p->SetGUID(guid);
    p->SetNetworkIDManager(networkIdManager); // Still need to set the NetworkIDManager
    p->CreatePhysics(m_physicsWorld->GetWorld(), 0, 10, 0); // Create physics component
    return p;
}

// --- REPLACE remove_player ---
void Server::remove_player(RakNet::RakNetGUID guid) {
    // The Player's destructor will handle deleting the PlayerPhysics component.
    // We just need to find the player and delete it from our vector.
    players.erase(std::remove_if(players.begin(), players.end(),
        // Explicitly specify 'bool' as the return type for the lambda
        [&](Player* p) -> bool {
            if (p && p->GetGUID() == guid) {
                delete p; // This triggers Player's destructor, cleaning up its physics object
                return true; // Returns true for removal
            }
            return false; // Returns false, keep the element
        }), players.end());
}
--------------------------------------------------------------------------------

// File: Server.h
--------------------------------------------------------------------------------
#pragma once

#include <vector>
// #include <memory> // REMOVED: No longer using std::unique_ptr for PhysicsWorld

// RakNet Includes (essential for basic networking)
#include "RakPeerInterface.h"
#include "RakNetTypes.h"    // For RakNet::SystemAddress, RakNet::RakNetGUID
#include "BitStream.h"      // For RakNet::BitStream
#include "NetworkIDManager.h" // For NetworkIDManager (we manage it now)

// Bullet Physics Includes - NO LONGER NEEDED HERE, PhysicsWorld.h will handle it
// #include "btBulletDynamicsCommon.h"

// Custom Game Includes
#include "DataTypes.h" // For Brick, Vector3, PlayerInput, PlayerState
#include "Player.h"     // For Player class definition
#include "World.h"      // For World class definition
#include "PhysicsWorld.h" // NEW: Required for PhysicsWorld class

// No StudcraftConnection or StudcraftReplicaManager classes

class Server {
public:
    Server();
    ~Server();
    void Startup();
    void Run();
private:
    // REMOVED: init_physics() and deinit_physics()
    // void init_physics();
    // void deinit_physics();

    void init_networking();

    // Helper functions for sending specific data manually
    void send_world(RakNet::SystemAddress addr);
    void send_player_states_to_all_clients(); // NEW: For manual replication

    Player* create_player(RakNet::RakNetGUID guid);
    void remove_player(RakNet::RakNetGUID guid); // NEW: To handle disconnects

    RakNet::RakPeerInterface* peer;
    // No ReplicaManager3* replicaManager;
    RakNet::NetworkIDManager* networkIdManager; // We will manage this instance

    // REMOVED: Individual Bullet pointer member variables
    // btDiscreteDynamicsWorld* dynamicsWorld;
    // btDefaultCollisionConfiguration* c_config;
    // btCollisionDispatcher* dispatcher;
    // btBroadphaseInterface* broadphase;
    // btSequentialImpulseConstraintSolver* solver;

    // CHANGED: Manages all of Bullet for us (now a raw pointer)
    PhysicsWorld* m_physicsWorld;

    World* world;
    std::vector<Player*> players;
};
--------------------------------------------------------------------------------

// File: World.cpp
--------------------------------------------------------------------------------
#include "World.h"
#include "btBulletDynamicsCommon.h" // Include the full header for implementation

// Default constructor (NEW)
World::World() : physicsWorld(nullptr) {}

// The constructor now takes the physics world and stores it.
World::World(btDiscreteDynamicsWorld* dynamicsWorld) : physicsWorld(dynamicsWorld) {}

// Destructor to clean up physics objects created by this World
World::~World() {
    // The destructor now simply calls Clear() to perform cleanup.
    Clear();
}

void World::Clear() {
    // This is the safe way to do what the destructor does:
    // 1. Remove rigid bodies from the physics world first.
    if (physicsWorld) {
        for (size_t i = 0; i < rigidBodies.size(); ++i) {
            if (rigidBodies[i]) { // Defensive check
                physicsWorld->removeRigidBody(rigidBodies[i]);
            }
        }
    }

    // 2. Delete allocated physics objects from memory.
    // Ensure you delete each pointer individually.
    for (size_t i = 0; i < rigidBodies.size(); ++i) {
        delete rigidBodies[i];
    }
    for (size_t i = 0; i < motionStates.size(); ++i) {
        delete motionStates[i];
    }
    for (size_t i = 0; i < collisionShapes.size(); ++i) {
        delete collisionShapes[i];
    }

    // 3. Clear the vectors to remove all elements and free their memory.
    bricks.clear();
    rigidBodies.clear();
    motionStates.clear();
    collisionShapes.clear();
}


void World::GenerateSimplePlatform() {
    // Call Clear() to safely remove any existing bricks and physics objects
    // before generating a new platform. This prevents memory leaks and issues
    // if GenerateSimplePlatform is called multiple times.
    Clear();

    const int world_size = 16;
    const float brick_step = 2.0f; // Distance between brick centers

    for (int i = -world_size / 2; i < world_size / 2; ++i) {
        for (int j = -world_size / 2; j < world_size / 2; ++j) {
            Brick floor_tile = {0}; // Initialize to zeros
            floor_tile.x = (float)i * brick_step;
            floor_tile.y = 0.0f; // Visual Y position for the bottom of the brick
            floor_tile.z = (float)j * brick_step;

            floor_tile.id = 1;   // Example ID
            floor_tile.c_id = 7; // Example color ID

            bricks.push_back(floor_tile);

            // --- Physics Body Creation for each brick ---
            if (this->physicsWorld) {
                // 1. Define the collision shape. A box of 1x0.1x1 units.
                //    btBoxShape takes half-extents, so a 2x0.2x2 brick needs (1.0f, 0.1f, 1.0f)
                btCollisionShape* groundShape = new btBoxShape(btVector3(1.0f, 0.1f, 1.0f));
                collisionShapes.push_back(groundShape); // Store for cleanup

                // 2. Set its initial position and orientation in the world.
                //    The physics body's origin (center) should align with the visual brick's center.
                //    If floor_tile.y is the visual bottom, the physics body's center is floor_tile.y + half_height.
                btTransform groundTransform;
                groundTransform.setIdentity();
                groundTransform.setOrigin(btVector3(floor_tile.x, floor_tile.y + 0.1f, floor_tile.z)); // +0.1f for half height of the box (0.2f / 2)

                // 3. Set mass to 0 for a static object (immovable).
                btScalar mass(0.0);
                // Static objects have zero inertia
                btVector3 localInertia(0, 0, 0); 

                // 4. Create the motion state and rigid body, then add to the physics world.
                btDefaultMotionState* myMotionState = new btDefaultMotionState(groundTransform);
                motionStates.push_back(myMotionState); // Store for cleanup

                btRigidBody::btRigidBodyConstructionInfo rbInfo(mass, myMotionState, groundShape, localInertia);
                btRigidBody* body = new btRigidBody(rbInfo);
                rigidBodies.push_back(body); // Store for cleanup

                this->physicsWorld->addRigidBody(body); // Add to the physics simulation
            }
        }
    }
}

const std::vector<Brick>& World::GetBricks() const { 
    return bricks; 
}
--------------------------------------------------------------------------------

// File: World.h
--------------------------------------------------------------------------------
#pragma once

#include <vector>
#include "DataTypes.h" // Assuming this contains your Brick struct
#include "btBulletDynamicsCommon.h" // Include for btDiscreteDynamicsWorld, btCollisionShape, btDefaultMotionState, btRigidBody

class World {
public:
    // Default constructor (NEW)
    World();
    // Constructor to inject the physics world
    World(btDiscreteDynamicsWorld* dynamicsWorld);

    // Destructor to clean up physics shapes and motion states created by this World
    ~World();

    void GenerateSimplePlatform(); // Renamed from GeneratePlatform
    const std::vector<Brick>& GetBricks() const;

    // Added Clear function for safe world regeneration
    void Clear();

private:
    std::vector<Brick> bricks;
    btDiscreteDynamicsWorld* physicsWorld; // Pointer to the physics world
    std::vector<btCollisionShape*> collisionShapes; // To manage shapes created by World
    std::vector<btDefaultMotionState*> motionStates; // To manage motion states created by World
    std::vector<btRigidBody*> rigidBodies; // To manage rigid bodies created by World
};
--------------------------------------------------------------------------------

// File: main.cpp
--------------------------------------------------------------------------------
#define _WINSOCKAPI_
#define _WINSOCK_DEPRECATED_NO_WARNINGS

#include "Server.h"

int main(){
    Server* s = new Server();
    s->Startup();
    s->Run();
    delete s;
    return 0;
}
--------------------------------------------------------------------------------
