#define _WINSOCKAPI_ // ADDED: To resolve C4005 warning
#define _WINSOCK_DEPRECATED_NO_WARNINGS

#include "Server.h"
#include "MessageIdentifiers.h"
#include "BitStream.h"
#include "GetTime.h"
// #include "btBulletDynamicsCommon.h" // No longer needed directly here, PhysicsWorld encapsulates it
#include <iostream>
#include <algorithm> // For std::remove_if
#include <vector>
#include <windows.h> // For Sleep

const unsigned char ID_SERVER_WORLD_DATA = 0x82;
const unsigned char ID_PLAYER_ACTION = 0x88;
const unsigned char ID_PLAYER_STATES = 0x89;
const unsigned char ID_PLAYER_DISCONNECT_NOTIFICATION = 0x90;

// Server class constructor
Server::Server() :
    peer(nullptr),
    networkIdManager(nullptr),
    m_physicsWorld(nullptr), // Initialize raw pointer to nullptr
    world(nullptr) // Initialize world to nullptr FIRST
{
    // NEW: Create the physics world
    m_physicsWorld = new PhysicsWorld();

    // Now that the physics world exists, create the game world,
    // passing it the raw pointer to the dynamicsWorld obtained from PhysicsWorld.
    world = new World(m_physicsWorld->GetWorld());
}

// Server class destructor
Server::~Server() {
    // Clean up players. The Player's destructor will handle its PlayerPhysics cleanup.
    for (size_t i = 0; i < players.size(); ++i) {
        delete players[i]; // This triggers Player's destructor, cleaning up its physics object
    }
    players.clear();

    // Cleanup world (this will now call World::~World() which cleans its physics objects)
    delete world;
    world = nullptr;

    // ADDED: Clean up the physics world (since it's a raw pointer now)
    delete m_physicsWorld;
    m_physicsWorld = nullptr; // Set to nullptr after deletion

    // Cleanup RakNet components
    if (peer) {
        RakNet::RakPeerInterface::DestroyInstance(peer);
        peer = nullptr;
    }
    delete networkIdManager;
    networkIdManager = nullptr;
}

// Server Startup function (Corrected)
void Server::Startup(){
    init_networking();

    world->GenerateSimplePlatform();

    std::cout << "[OK] Startup Complete\n";
}

void Server::init_networking(){
    peer = RakNet::RakPeerInterface::GetInstance();

    networkIdManager = new RakNet::NetworkIDManager();

    RakNet::SocketDescriptor sd(37373,0);
    peer->Startup(10,&sd,1);
    peer->SetMaximumIncomingConnections(10);
}

void Server::Run(){
    RakNet::Packet*p;
    std::cout << "[OK] Running...\n";

    RakNet::TimeMS lastPhysicsTick = RakNet::GetTimeMS();
    const RakNet::TimeMS physicsUpdateInterval = 1000 / 60; // 60 ticks per second

    while(true){
        for(p=peer->Receive();p;peer->DeallocatePacket(p),p=peer->Receive()){
            if(p->length==0)continue;
            unsigned char mID=p->data[0];

            if(mID==ID_NEW_INCOMING_CONNECTION){
                std::cout << "New incoming connection from " << p->systemAddress.ToString() << std::endl;
                send_world(p->systemAddress);
                Player* player = create_player(p->guid);
                players.push_back(player);

            }
            else if(mID==ID_PLAYER_ACTION){
                for(size_t i=0;i<players.size();++i){
                    if(players[i] && players[i]->GetGUID()==p->guid){
                        RakNet::BitStream bs(p->data,p->length,false);
                        bs.IgnoreBytes(1);
                        PlayerInput pi;
                        bs.Read(pi);
                        players[i]->ProcessInput(pi);
                        break;
                    }
                }
            } else if (mID==ID_CONNECTION_LOST||mID==ID_DISCONNECTION_NOTIFICATION){
                std::cout << "Client disconnected: " << p->systemAddress.ToString() << std::endl;
                remove_player(p->guid);
                RakNet::BitStream bs;
                bs.Write(ID_PLAYER_DISCONNECT_NOTIFICATION);
                bs.Write(p->guid);
                peer->Send(&bs, HIGH_PRIORITY, RELIABLE_ORDERED, 0, p->systemAddress, true);
            }
        }

        RakNet::TimeMS currentTime = RakNet::GetTimeMS();
        if (currentTime - lastPhysicsTick >= physicsUpdateInterval) {
            // NEW: Step the physics world using the PhysicsWorld object
            m_physicsWorld->Step(physicsUpdateInterval / 1000.f);
            send_player_states_to_all_clients();
            lastPhysicsTick = currentTime;
        }

        Sleep(15);
    }
}

void Server::send_world(RakNet::SystemAddress addr){
    RakNet::BitStream bs;
    bs.Write((unsigned char)ID_SERVER_WORLD_DATA);

    Vector3 pos;
    pos.x = 0;
    pos.y = 10;
    pos.z = 0;
    bs.Write(pos);

    const std::vector<Brick>&bricks=world->GetBricks();
    bs.Write((unsigned int)bricks.size());

    for(size_t i=0; i<bricks.size();++i){
        bs.Write((char*)&(bricks[i]),sizeof(Brick));
    }
    peer->Send(&bs,HIGH_PRIORITY,RELIABLE_ORDERED,0,addr,false);
}

// --- REPLACE send_player_states_to_all_clients ---
void Server::send_player_states_to_all_clients() {
    if (players.empty()) return;
    RakNet::BitStream bs;
    bs.Write(ID_PLAYER_STATES);
    bs.Write((unsigned int)players.size());

    for (size_t i = 0; i < players.size(); ++i) {
        Player* p = players[i];
        // Get the rigid body from the PlayerPhysics component
        if (p && p->GetPhysics() && p->GetPhysics()->GetBody()) {
            btTransform t;
            p->GetPhysics()->GetBody()->getMotionState()->getWorldTransform(t);
            PlayerState ps;
            ps.guid = p->GetGUID();
            ps.position.x = t.getOrigin().x();
            ps.position.y = t.getOrigin().y();
            ps.position.z = t.getOrigin().z();
            ps.rotation = t.getRotation();
            bs.Write((char*)&ps, sizeof(PlayerState));
        }
    }
    peer->Send(&bs, HIGH_PRIORITY, UNRELIABLE_SEQUENCED, 0, RakNet::UNASSIGNED_SYSTEM_ADDRESS, true);
}

// --- REPLACE create_player ---
Player* Server::create_player(RakNet::RakNetGUID guid) {
    Player* p = new Player();
    p->SetGUID(guid);
    p->SetNetworkIDManager(networkIdManager); // Still need to set the NetworkIDManager
    p->CreatePhysics(m_physicsWorld->GetWorld(), 0, 10, 0); // Create physics component
    return p;
}

// --- REPLACE remove_player ---
void Server::remove_player(RakNet::RakNetGUID guid) {
    // The Player's destructor will handle deleting the PlayerPhysics component.
    // We just need to find the player and delete it from our vector.
    players.erase(std::remove_if(players.begin(), players.end(),
        // Explicitly specify 'bool' as the return type for the lambda
        [&](Player* p) -> bool {
            if (p && p->GetGUID() == guid) {
                delete p; // This triggers Player's destructor, cleaning up its physics object
                return true; // Returns true for removal
            }
            return false; // Returns false, keep the element
        }), players.end());
}