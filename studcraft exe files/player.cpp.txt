#include "Player.h"
#include <iostream>
#define _USE_MATH_DEFINES
#include <math.h>

// --- In the Player::Player() constructor, change `m_physics(nullptr)` to: ---
// Initialize m_physics to NULL and m_networkIDManager to NULL
Player::Player() : m_physics(NULL), guid(RakNet::UNASSIGNED_RAKNET_GUID), m_networkIDManager(NULL) {}

// --- In the Player::~Player() destructor, ADD cleanup logic: ---
Player::~Player() {
    delete m_physics; // This will call the PlayerPhysics destructor
    m_physics = NULL;
    // Note: m_networkIDManager is typically managed externally (e.g., by Server),
    // so we don't delete it here.
}

// --- In Player::CreatePhysics, REPLACE `m_physics = std::make_unique...` with: ---
void Player::CreatePhysics(btDiscreteDynamicsWorld* world, float x, float y, float z) {
    m_physics = new PlayerPhysics(world, x, y, z);
}

// THIS IS THE PRIMARY BUG FIX
void Player::ProcessInput(const PlayerInput& input) {
    if (!m_physics || !m_physics->GetBody()) return;

    btRigidBody* body = m_physics->GetBody();
    btTransform t;
    body->getMotionState()->getWorldTransform(t);

    // 1. Apply YAW rotation from mouse look. PITCH is now ignored here.
    if (input.delta_yaw != 0) {
        btQuaternion rotation = t.getRotation();
        // We only apply the yaw rotation around the WORLD's Y-axis (0,1,0).
        btQuaternion yaw_rotation(btVector3(0, 1, 0), input.delta_yaw * -0.005f);
        t.setRotation(rotation * yaw_rotation);
        body->getMotionState()->setWorldTransform(t); // Update transform for rotation
    }

    // 2. Calculate movement direction. This code is already correct because it
    //    bases its direction on the physics body's transform, which we just updated.
    btVector3 move_direction(0, 0, 0);
    // Get forward and right vectors relative to the player's current orientation
    // Ensure they are horizontal by setting Y to 0 and re-normalizing.
    btVector3 forward = t.getBasis().getColumn(2); forward.setY(0); forward.normalize();
    btVector3 right   = t.getBasis().getColumn(0); right.setY(0);   right.normalize();

    if (input.is_forward_pressed)  move_direction -= forward; // Move along the negative forward vector
    if (input.is_backward_pressed) move_direction += forward; // Move along the positive forward vector
    if (input.is_left_pressed)     move_direction -= right;   // Move along the negative right vector (left)
    if (input.is_right_pressed)    move_direction += right;   // Move along the positive right vector (right)

    // --- The rest of the function (setting velocity, jump, activate) is perfect and needs no changes. ---
    // 3. Set velocity
    // Preserve the current vertical velocity (for gravity/jumping)
    float current_y_velocity = body->getLinearVelocity().y();
    if (move_direction.length2() > 0.0f) { // Only apply horizontal velocity if there's input
        move_direction.normalize();
        body->setLinearVelocity(move_direction * 5.f + btVector3(0, current_y_velocity, 0));
    } else {
        // If no movement keys are pressed, only preserve vertical velocity
        body->setLinearVelocity(btVector3(0, current_y_velocity, 0));
    }

    // 4. Handle jumping
    // A raycast downwards is a better "isGrounded" check, but this is fine for now
    // Prevents "double jumps" by checking if the player is near the ground.
    if (input.is_jump_pressed && (body->getCenterOfMassPosition().y() < 1.8f)) {
        body->applyCentralImpulse(btVector3(0, 7.f, 0)); // Apply an upward impulse
    }

    // 5. Ensure the body is active so it doesn't fall asleep
    // Bullet physics bodies can "sleep" to save CPU if they aren't moving.
    // Activating it ensures it responds to impulses and continuous velocity changes.
    body->activate(true);
}

// Player::GetPhysics() now returns the raw pointer directly
PlayerPhysics* Player::GetPhysics() const { return m_physics; }
RakNet::RakNetGUID Player::GetGUID() const { return guid; }
void Player::SetGUID(RakNet::RakNetGUID g) { this->guid = g; }

// ADDED: Implementation for SetNetworkIDManager
void Player::SetNetworkIDManager(RakNet::NetworkIDManager* networkIDManager) {
    m_networkIDManager = networkIDManager;
    // Removed problematic line: m_networkIDManager->SetNetworkID(this, guid.g);
    // This line is typically for ReplicaManager, not direct manual NetworkID assignment.
    // For your current manual replication, simply storing the manager is sufficient.
}