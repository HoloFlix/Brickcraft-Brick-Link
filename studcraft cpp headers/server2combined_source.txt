
// File: DataTypes.h
--------------------------------------------------------------------------------
#pragma once

// Must include RakNetTypes.h for RakNet::RakNetGUID
#include "RakNetTypes.h" // Needed for RakNet::RakNetGUID
#include "btBulletCollisionCommon.h" // Needed for btQuaternion

#pragma pack(push, 1)
struct Brick { char u[3]; float x, y, z; int id; int c_id; char r[9]; };
#pragma pack(pop)

struct Vector3 { float x,y,z; };

struct PlayerInput {
    // A world-space vector indicating the desired movement direction.
    btVector3 move_vector;
    bool is_jump_pressed;
};

// Struct to hold player state for network transmission
struct PlayerState {
    RakNet::RakNetGUID guid;
    Vector3 position;
	btQuaternion rotation;
};
--------------------------------------------------------------------------------

// File: PhysicsWorld.cpp
--------------------------------------------------------------------------------
#include "PhysicsWorld.h"

PhysicsWorld::PhysicsWorld() {
    collisionConfiguration = new btDefaultCollisionConfiguration();
    dispatcher = new btCollisionDispatcher(collisionConfiguration);
    overlappingPairCache = new btDbvtBroadphase();
    solver = new btSequentialImpulseConstraintSolver();
    dynamicsWorld = new btDiscreteDynamicsWorld(dispatcher, overlappingPairCache, solver, collisionConfiguration);
    dynamicsWorld->setGravity(btVector3(0, -9.81f, 0));
}

PhysicsWorld::~PhysicsWorld() {
    // With raw pointers, we must manually delete in the reverse order of creation.
    // Clean up all collision objects from the dynamics world before deleting the world itself
    if (dynamicsWorld) {
        for (int i = dynamicsWorld->getNumCollisionObjects() - 1; i >= 0; i--) {
            btCollisionObject* obj = dynamicsWorld->getCollisionObjectArray()[i];
            btRigidBody* body = btRigidBody::upcast(obj);
            if (body && body->getMotionState()) {
                delete body->getMotionState();
            }
            dynamicsWorld->removeCollisionObject(obj);
            delete obj; // Delete the collision object itself
        }
    }

    delete dynamicsWorld;
    dynamicsWorld = nullptr; // Set to nullptr after deletion
    delete solver;
    solver = nullptr;
    delete overlappingPairCache;
    overlappingPairCache = nullptr;
    delete dispatcher;
    dispatcher = nullptr;
    delete collisionConfiguration;
    collisionConfiguration = nullptr;
}

void PhysicsWorld::Step(float dt) {
    if (dynamicsWorld) { // Add a null check for safety
        dynamicsWorld->stepSimulation(dt, 10); // up to 10 substeps per frame
    }
}
--------------------------------------------------------------------------------

// File: PhysicsWorld.h
--------------------------------------------------------------------------------
#pragma once
#include <btBulletDynamicsCommon.h>
// #include <memory> // REMOVED: No longer using std::unique_ptr for dynamicsWorld

class PhysicsWorld {
public:
    PhysicsWorld();
    ~PhysicsWorld();

    void Step(float dt);

    // Changed to return raw pointer directly, as dynamicsWorld is now a raw pointer
    btDiscreteDynamicsWorld* GetWorld() { return dynamicsWorld; }

private:
    btDefaultCollisionConfiguration* collisionConfiguration;
    btCollisionDispatcher* dispatcher;
    btBroadphaseInterface* overlappingPairCache;
    btSequentialImpulseConstraintSolver* solver;
    // Changed from std::unique_ptr to raw pointer
    btDiscreteDynamicsWorld* dynamicsWorld;
};
--------------------------------------------------------------------------------

// File: Player.cpp
--------------------------------------------------------------------------------
#include "Player.h"
#include <iostream>
#define _USE_MATH_DEFINES
#include <math.h>
#include "PlayerPhysics.h"
#include "StudcraftBrickSystem.h"

// --- In the Player::Player() constructor, change `m_physics(nullptr)` to: ---
// Initialize m_physics to NULL and m_networkIDManager to NULL
Player::Player() : m_physics(NULL), m_networkIDManager(NULL), m_yaw(0.0f) {}

// --- In the Player::~Player() destructor, ADD cleanup logic: ---
Player::~Player() {
    delete m_physics; // This will call the PlayerPhysics destructor
    m_physics = NULL;
    // Note: m_networkIDManager is typically managed externally (e.g., by Server),
    // so we don't delete it here.
}

// --- In Player::CreatePhysics, REPLACE `m_physics = std::make_unique...` with: ---
void Player::CreatePhysics(btDiscreteDynamicsWorld* world, float x, float y, float z) {
    m_physics = new PlayerPhysics(world, x, y, z);
}

void Player::ProcessInput(const PlayerInput& input) {
    if (!m_physics) return;
    btRigidBody* body = m_physics->GetBody();
    if (!body) return;

    body->activate(true);

    btVector3 move_vec = input.move_vector;
    btTransform trans;
    body->getMotionState()->getWorldTransform(trans);

    // --- 1. Movement: Directly apply the world-space vector from the client ---
    if (!move_vec.isZero()) {
        const float walk_speed = 4.0f;
        btVector3 new_velocity = move_vec * walk_speed;
        new_velocity.setY(body->getLinearVelocity().getY()); // Preserve gravity
        body->setLinearVelocity(new_velocity);

        // --- 2. Rotation: Make the body face the direction of movement ---
        btVector3 forward_dir(0, 0, -1);
        // Create a quaternion that rotates from "forward" to the new move direction.
        btQuaternion new_rotation = shortestArcQuat(forward_dir, move_vec);
        trans.setRotation(new_rotation);
        body->getMotionState()->setWorldTransform(trans);

    } else {
        // No movement input, stop horizontal motion.
        body->setLinearVelocity(btVector3(0, body->getLinearVelocity().getY(), 0));
    }

    // --- 3. Jumping ---
    if(input.is_jump_pressed) {
        if (fabs(body->getLinearVelocity().getY()) < 0.1f) {
             const float jump_force = 6.0f;
             body->applyCentralImpulse(btVector3(0, jump_force, 0));
        }
    }
}

// Player::GetPhysics() now returns the raw pointer directly
PlayerPhysics* Player::GetPhysics() const { return m_physics; }
RakNet::RakNetGUID Player::GetGUID() const { return guid; }
void Player::SetGUID(RakNet::RakNetGUID g) { this->guid = g; }

// ADDED: Implementation for SetNetworkIDManager
void Player::SetNetworkIDManager(RakNet::NetworkIDManager* networkIDManager) {
    m_networkIDManager = networkIDManager;
    // Removed problematic line: m_networkIDManager->SetNetworkID(this, guid.g);
    // This line is typically for ReplicaManager, not direct manual NetworkID assignment.
    // For your current manual replication, simply storing the manager is sufficient.
}
--------------------------------------------------------------------------------

// File: Player.h
--------------------------------------------------------------------------------
#pragma once

#include "DataTypes.h"
#include "RakNetTypes.h"
#include "PlayerPhysics.h" // NEW
#include "NetworkIDManager.h" // ADDED: Required for SetNetworkIDManager

// #include <memory>          // REMOVED: No longer using std::unique_ptr for m_physics

class Player {
public:
    Player();
    ~Player();

    void CreatePhysics(btDiscreteDynamicsWorld* world, float x, float y, float z);
    void ProcessInput(const PlayerInput& input);

    PlayerPhysics* GetPhysics() const; // Renamed for clarity
    RakNet::RakNetGUID GetGUID() const;
    void SetGUID(RakNet::RakNetGUID g);

    // ADDED: Declaration for SetNetworkIDManager
    void SetNetworkIDManager(RakNet::NetworkIDManager* networkIDManager);

private:
    PlayerPhysics* m_physics;
    RakNet::RakNetGUID guid;
    RakNet::NetworkIDManager* m_networkIDManager;
    float m_yaw; // **<-- ADD THIS LINE**
};
--------------------------------------------------------------------------------

// File: PlayerPhysics.cpp
--------------------------------------------------------------------------------
#include "PlayerPhysics.h"
#include "StudcraftBrickSystem.h"

PlayerPhysics::PlayerPhysics(btDiscreteDynamicsWorld* world, float x, float y, float z) : world(world) {
    btCompoundShape* compound = new btCompoundShape();
    shape = compound;

    float brick_height = 3.0f * PLATE_HEIGHT;
    btVector3 halfExtents(1.0f * STUD_UNIT, 1.5f * PLATE_HEIGHT, 2.0f * STUD_UNIT);
    btBoxShape* single_brick_shape = new btBoxShape(halfExtents);
    
    btTransform local_trans;
    local_trans.setIdentity();
    local_trans.setOrigin(btVector3(0, -brick_height, 0));
    compound->addChildShape(local_trans, single_brick_shape);
    local_trans.setOrigin(btVector3(0, 0, 0));
    compound->addChildShape(local_trans, single_brick_shape);
    local_trans.setOrigin(btVector3(0, brick_height, 0));
    compound->addChildShape(local_trans, single_brick_shape);
    
    motionState = new btDefaultMotionState(btTransform(btQuaternion(0, 0, 0, 1), btVector3(x, y, z)));
    
    btScalar mass = 1.0f;
    btVector3 inertia(0, 0, 0);
    shape->calculateLocalInertia(mass, inertia);
    btRigidBody::btRigidBodyConstructionInfo rbInfo(mass, motionState, shape, inertia);
    body = new btRigidBody(rbInfo);
    
    // **THE DEFINITIVE FIX for Camera Lean/Roll:**
    // This tells the physics engine that this body can ONLY rotate around the Y (up) axis.
    // All other rotational forces (like from collisions) will be ignored.
    body->setAngularFactor(btVector3(0, 1, 0));
    
    body->setActivationState(DISABLE_DEACTIVATION);
    body->setCcdMotionThreshold(1e-7f);
    body->setCcdSweptSphereRadius(0.4f);

    world->addRigidBody(body);
}

PlayerPhysics::~PlayerPhysics() {
    world->removeRigidBody(body);
    delete body;
    delete motionState;
    delete shape;
}
--------------------------------------------------------------------------------

// File: PlayerPhysics.h
--------------------------------------------------------------------------------
#pragma once
#include <btBulletDynamicsCommon.h>

class PlayerPhysics {
public:
    PlayerPhysics(btDiscreteDynamicsWorld* world, float x, float y, float z);
    ~PlayerPhysics();

    btRigidBody* GetBody() { return body; }

private:
    btCollisionShape* shape;
    btDefaultMotionState* motionState;
    btRigidBody* body;
    btDiscreteDynamicsWorld* world;
};
--------------------------------------------------------------------------------

// File: Server.cpp
--------------------------------------------------------------------------------
#define _WINSOCKAPI_ // ADDED: To resolve C4005 warning
#define _WINSOCK_DEPRECATED_NO_WARNINGS

#include "Server.h"
#include "MessageIdentifiers.h"
#include "BitStream.h"
#include "GetTime.h"
// #include "btBulletDynamicsCommon.h" // No longer needed directly here, PhysicsWorld encapsulates it
#include <iostream>
#include <algorithm> // For std::remove_if
#include <vector>
#include <windows.h> // For Sleep

const unsigned char ID_SERVER_WORLD_DATA = 0x82;
const unsigned char ID_PLAYER_ACTION = 0x88;
const unsigned char ID_PLAYER_STATES = 0x89;
const unsigned char ID_PLAYER_DISCONNECT_NOTIFICATION = 0x90;

// Server class constructor
Server::Server() :
    peer(nullptr),
    networkIdManager(nullptr),
    m_physicsWorld(nullptr), // Initialize raw pointer to nullptr
    world(nullptr) // Initialize world to nullptr FIRST
{
    // NEW: Create the physics world
    m_physicsWorld = new PhysicsWorld();

    // Now that the physics world exists, create the game world,
    // passing it the raw pointer to the dynamicsWorld obtained from PhysicsWorld.
    world = new World(m_physicsWorld->GetWorld());
}

// Server class destructor
Server::~Server() {
    // Clean up players. The Player's destructor will handle its PlayerPhysics cleanup.
    for (size_t i = 0; i < players.size(); ++i) {
        delete players[i]; // This triggers Player's destructor, cleaning up its physics object
    }
    players.clear();

    // Cleanup world (this will now call World::~World() which cleans its physics objects)
    delete world;
    world = nullptr;

    // ADDED: Clean up the physics world (since it's a raw pointer now)
    delete m_physicsWorld;
    m_physicsWorld = nullptr; // Set to nullptr after deletion

    // Cleanup RakNet components
    if (peer) {
        RakNet::RakPeerInterface::DestroyInstance(peer);
        peer = nullptr;
    }
    delete networkIdManager;
    networkIdManager = nullptr;
}

// Server Startup function (Corrected)
void Server::Startup() {
    init_networking(); // Sets up RakNet peer

    m_physicsWorld = new PhysicsWorld(); // Creates Bullet Physics world
    
    // Pass the physics world to our game World so it can add bodies
    world = new World(m_physicsWorld->GetWorld()); 

    // **THE DEFINITIVE FIX:**
    // We must call this function here to actually create the platform geometry.
    std::cout << "[SERVER] Generating world..." << std::endl;
    world->GenerateSimplePlatform();
    std::cout << "[SERVER] World generated with " << world->GetBricks().size() << " bricks." << std::endl;
}

void Server::init_networking(){
    peer = RakNet::RakPeerInterface::GetInstance();

    networkIdManager = new RakNet::NetworkIDManager();

    RakNet::SocketDescriptor sd(37373,0);
    peer->Startup(10,&sd,1);
    peer->SetMaximumIncomingConnections(10);
}

void Server::Run(){
    RakNet::Packet*p;
    std::cout << "[OK] Running...\n";

    RakNet::TimeMS lastPhysicsTick = RakNet::GetTimeMS();
    const RakNet::TimeMS physicsUpdateInterval = 1000 / 60; // 60 ticks per second

    while(true){
        for(p=peer->Receive();p;peer->DeallocatePacket(p),p=peer->Receive()){
            if(p->length==0)continue;
            unsigned char mID=p->data[0];

            if(mID==ID_NEW_INCOMING_CONNECTION){
                std::cout << "New incoming connection from " << p->systemAddress.ToString() << std::endl;
                send_world(p->systemAddress);
                Player* player = create_player(p->guid);
                players.push_back(player);

            }
            else if(mID==ID_PLAYER_ACTION){
                for(size_t i=0;i<players.size();++i){
                    if(players[i] && players[i]->GetGUID()==p->guid){
                        RakNet::BitStream bs(p->data,p->length,false);
                        bs.IgnoreBytes(1);
                        PlayerInput pi;
                        bs.Read(pi);
                        players[i]->ProcessInput(pi);
                        break;
                    }
                }
            } else if (mID==ID_CONNECTION_LOST||mID==ID_DISCONNECTION_NOTIFICATION){
                std::cout << "Client disconnected: " << p->systemAddress.ToString() << std::endl;
                remove_player(p->guid);
                RakNet::BitStream bs;
                bs.Write(ID_PLAYER_DISCONNECT_NOTIFICATION);
                bs.Write(p->guid);
                peer->Send(&bs, HIGH_PRIORITY, RELIABLE_ORDERED, 0, p->systemAddress, true);
            }
        }

        RakNet::TimeMS currentTime = RakNet::GetTimeMS();
        if (currentTime - lastPhysicsTick >= physicsUpdateInterval) {
            // NEW: Step the physics world using the PhysicsWorld object
            m_physicsWorld->Step(physicsUpdateInterval / 1000.f);
            send_player_states_to_all_clients();
            lastPhysicsTick = currentTime;
        }

        Sleep(15);
    }
}

void Server::send_world(RakNet::SystemAddress addr) {
    RakNet::BitStream bs_out;
    bs_out.Write((unsigned char)ID_SERVER_WORLD_DATA);

    const std::vector<Brick>& bricks = world->GetBricks();
    unsigned int brick_count = bricks.size();

    // First, write the number of bricks that will be sent.
    bs_out.Write(brick_count);

    std::cout << "[SERVER] Sending " << brick_count << " bricks to " << addr.ToString() << std::endl;

    // Then, write the data for each brick.
    for (unsigned int i = 0; i < brick_count; ++i) {
        bs_out.Write((char*)&bricks[i], sizeof(Brick));
    }

    peer->Send(&bs_out, HIGH_PRIORITY, RELIABLE_ORDERED, 0, addr, false);
}

// --- REPLACE send_player_states_to_all_clients ---
void Server::send_player_states_to_all_clients() {
    if (players.empty()) return;
    RakNet::BitStream bs;
    bs.Write(ID_PLAYER_STATES);
    bs.Write((unsigned int)players.size());

    for (size_t i = 0; i < players.size(); ++i) {
        Player* p = players[i];
        // Get the rigid body from the PlayerPhysics component
        if (p && p->GetPhysics() && p->GetPhysics()->GetBody()) {
            btTransform t;
            p->GetPhysics()->GetBody()->getMotionState()->getWorldTransform(t);
            PlayerState ps;
            ps.guid = p->GetGUID();
            ps.position.x = t.getOrigin().x();
            ps.position.y = t.getOrigin().y();
            ps.position.z = t.getOrigin().z();
            ps.rotation = t.getRotation();
            bs.Write((char*)&ps, sizeof(PlayerState));
        }
    }
    peer->Send(&bs, HIGH_PRIORITY, UNRELIABLE_SEQUENCED, 0, RakNet::UNASSIGNED_SYSTEM_ADDRESS, true);
}

// --- REPLACE create_player ---
Player* Server::create_player(RakNet::RakNetGUID guid) {
	Vector3 spawn_pos = {0.0f, 2.0f, 0.0f};
    Player* p = new Player();
    p->SetGUID(guid);
    p->SetNetworkIDManager(networkIdManager); // Still need to set the NetworkIDManager
    p->CreatePhysics(m_physicsWorld->GetWorld(), 0, 10, 0); // Create physics component
    return p;
}

// --- REPLACE remove_player ---
void Server::remove_player(RakNet::RakNetGUID guid) {
    // The Player's destructor will handle deleting the PlayerPhysics component.
    // We just need to find the player and delete it from our vector.
    players.erase(std::remove_if(players.begin(), players.end(),
        // Explicitly specify 'bool' as the return type for the lambda
        [&](Player* p) -> bool {
            if (p && p->GetGUID() == guid) {
                delete p; // This triggers Player's destructor, cleaning up its physics object
                return true; // Returns true for removal
            }
            return false; // Returns false, keep the element
        }), players.end());
}
--------------------------------------------------------------------------------

// File: Server.h
--------------------------------------------------------------------------------
#pragma once

#include <vector>
// #include <memory> // REMOVED: No longer using std::unique_ptr for PhysicsWorld

// RakNet Includes (essential for basic networking)
#include "RakPeerInterface.h"
#include "RakNetTypes.h"    // For RakNet::SystemAddress, RakNet::RakNetGUID
#include "BitStream.h"      // For RakNet::BitStream
#include "NetworkIDManager.h" // For NetworkIDManager (we manage it now)

// Bullet Physics Includes - NO LONGER NEEDED HERE, PhysicsWorld.h will handle it
// #include "btBulletDynamicsCommon.h"

// Custom Game Includes
#include "DataTypes.h" // For Brick, Vector3, PlayerInput, PlayerState
#include "Player.h"     // For Player class definition
#include "World.h"      // For World class definition
#include "PhysicsWorld.h" // NEW: Required for PhysicsWorld class

// No StudcraftConnection or StudcraftReplicaManager classes

class Server {
public:
    Server();
    ~Server();
    void Startup();
    void Run();
private:
    // REMOVED: init_physics() and deinit_physics()
    // void init_physics();
    // void deinit_physics();

    void init_networking();

    // Helper functions for sending specific data manually
    void send_world(RakNet::SystemAddress addr);
    void send_player_states_to_all_clients(); // NEW: For manual replication

    Player* create_player(RakNet::RakNetGUID guid);
    void remove_player(RakNet::RakNetGUID guid); // NEW: To handle disconnects

    RakNet::RakPeerInterface* peer;
    // No ReplicaManager3* replicaManager;
    RakNet::NetworkIDManager* networkIdManager; // We will manage this instance

    // REMOVED: Individual Bullet pointer member variables
    // btDiscreteDynamicsWorld* dynamicsWorld;
    // btDefaultCollisionConfiguration* c_config;
    // btCollisionDispatcher* dispatcher;
    // btBroadphaseInterface* broadphase;
    // btSequentialImpulseConstraintSolver* solver;

    // CHANGED: Manages all of Bullet for us (now a raw pointer)
    PhysicsWorld* m_physicsWorld;

    World* world;
    std::vector<Player*> players;
};
--------------------------------------------------------------------------------

// File: StudcraftBrickSystem.h
--------------------------------------------------------------------------------
#pragma once

#include <vector>
#include <map>
#include <string>

// --- Base Unit Definitions ---
const float STUD_UNIT = 1.0f;
const float PLATE_HEIGHT = 0.4f;

// Forward declaration
class StudcraftBrick;

// **FIXED**: Using simple floats instead of btVector3 to avoid alignment errors in std::vector.
struct StudcraftSubPart {
    float mOffsetX, mOffsetY, mOffsetZ;
};

// A replica of the LegoBrick structure. It's a collection of sub-parts.
class StudcraftBrick {
public:
    int mDesignID;
    std::string mName;
    std::vector<StudcraftSubPart> mParts;

    StudcraftBrick() : mDesignID(0) {}
    StudcraftBrick(int id, const std::string& name) : mDesignID(id), mName(name) {}

    void AddSubPart(float x, float y, float z) {
        StudcraftSubPart part = {x, y, z};
        mParts.push_back(part);
    }
};

// The global catalog that holds all our brick definitions.
class StudcraftBrickCatalog {
public:
    static StudcraftBrickCatalog& GetInstance() {
        static StudcraftBrickCatalog instance;
        return instance;
    }

    void Initialize() {
        if (m_isInitialized) return;

        // Design ID 1: 1x1 Brick
        StudcraftBrick b1(1, "1x1 Brick");
        b1.AddSubPart(0.0f, 0.0f, 0.0f);
        m_brickTypes[b1.mDesignID] = b1;

        // Design ID 7: 2x2 Plate
        StudcraftBrick b7(7, "2x2 Plate");
        for (int x = 0; x < 2; ++x) {
            for (int z = 0; z < 2; ++z) {
                // **FIXED**: Explicitly casting to float to prevent C4244 warnings.
                b7.AddSubPart((float)x, 0.0f, (float)z);
            }
        }
        m_brickTypes[b7.mDesignID] = b7;

        // Design ID 8: 2x4 Brick
        StudcraftBrick b8(8, "2x4 Brick");
        for (int x = 0; x < 2; ++x) {
            for (int z = 0; z < 4; ++z) {
                b8.AddSubPart((float)x, 0.0f, (float)z);
            }
        }
        m_brickTypes[b8.mDesignID] = b8;

        m_isInitialized = true;
    }

    const StudcraftBrick* GetBrick(int designID) const {
        std::map<int, StudcraftBrick>::const_iterator it = m_brickTypes.find(designID);
        if (it != m_brickTypes.end()) {
            return &it->second;
        }
        return NULL;
    }

private:
    StudcraftBrickCatalog() : m_isInitialized(false) {}
    std::map<int, StudcraftBrick> m_brickTypes;
    bool m_isInitialized;
};
--------------------------------------------------------------------------------

// File: World.cpp
--------------------------------------------------------------------------------
#include "World.h"
#include "btBulletDynamicsCommon.h" // Include the full header for implementation
#include "StudcraftBrickSystem.h"

// Default constructor (NEW)
World::World() : physicsWorld(nullptr) {}

// The constructor now takes the physics world and stores it.
World::World(btDiscreteDynamicsWorld* dynamicsWorld) : physicsWorld(dynamicsWorld) {}

// Destructor to clean up physics objects created by this World
World::~World() {
    // The destructor now simply calls Clear() to perform cleanup.
    Clear();
}

void World::Clear() {
    // This is the safe way to do what the destructor does:
    // 1. Remove rigid bodies from the physics world first.
    if (physicsWorld) {
        for (size_t i = 0; i < rigidBodies.size(); ++i) {
            if (rigidBodies[i]) { // Defensive check
                physicsWorld->removeRigidBody(rigidBodies[i]);
            }
        }
    }

    // 2. Delete allocated physics objects from memory.
    // Ensure you delete each pointer individually.
    for (size_t i = 0; i < rigidBodies.size(); ++i) {
        delete rigidBodies[i];
    }
    for (size_t i = 0; i < motionStates.size(); ++i) {
        delete motionStates[i];
    }
    for (size_t i = 0; i < collisionShapes.size(); ++i) {
        delete collisionShapes[i];
    }

    // 3. Clear the vectors to remove all elements and free their memory.
    bricks.clear();
    rigidBodies.clear();
    motionStates.clear();
    collisionShapes.clear();
}


void World::GenerateSimplePlatform() {
    Clear();
    StudcraftBrickCatalog& catalog = StudcraftBrickCatalog::GetInstance();

    const int world_size_studs = 32;
    const StudcraftBrick* baseplate_def = catalog.GetBrick(7); // Get the 2x2 Plate
    if (!baseplate_def) return;

    // Place a grid of 2x2 plates
    for (int i = -world_size_studs / 2; i < world_size_studs / 2; i += 2) {
        for (int j = -world_size_studs / 2; j < world_size_studs / 2; j += 2) {
            Brick b;
            b.id = baseplate_def->mDesignID;
            b.c_id = 15; // Light Grey
            b.x = i * STUD_UNIT;
            b.y = 0;
            b.z = j * STUD_UNIT;
            bricks.push_back(b); // Send the main brick's info to the client

            // CRITICAL: Create physics bodies for each sub-part of this brick
			for (size_t p = 0; p < baseplate_def->mParts.size(); ++p) {
				const StudcraftSubPart& part = baseplate_def->mParts[p];

				// **FIXED**: Use the new float members instead of the old btVector3.
				btVector3 part_pos(
					b.x + (part.mOffsetX * STUD_UNIT),
					b.y + (part.mOffsetY * PLATE_HEIGHT * 3),
					b.z + (part.mOffsetZ * STUD_UNIT)
				);

                // Create a 1x1x1 physics box for the sub-part
                btCollisionShape* shape = new btBoxShape(btVector3(STUD_UNIT / 2.0f, (PLATE_HEIGHT * 3) / 2.0f, STUD_UNIT / 2.0f));
                collisionShapes.push_back(shape);

                btTransform transform;
                transform.setIdentity();
                transform.setOrigin(part_pos);
                
                btDefaultMotionState* motionState = new btDefaultMotionState(transform);
                motionStates.push_back(motionState);
                
                btRigidBody* body = new btRigidBody(btRigidBody::btRigidBodyConstructionInfo(0., motionState, shape));
                rigidBodies.push_back(body);
                physicsWorld->addRigidBody(body);
            }
        }
    }
}

const std::vector<Brick>& World::GetBricks() const { 
    return bricks; 
}
--------------------------------------------------------------------------------

// File: World.h
--------------------------------------------------------------------------------
#pragma once

#include <vector>
#include "DataTypes.h" // Assuming this contains your Brick struct
#include "btBulletDynamicsCommon.h" // Include for btDiscreteDynamicsWorld, btCollisionShape, btDefaultMotionState, btRigidBody

class World {
public:
    // Default constructor (NEW)
    World();
    // Constructor to inject the physics world
    World(btDiscreteDynamicsWorld* dynamicsWorld);

    // Destructor to clean up physics shapes and motion states created by this World
    ~World();

    void GenerateSimplePlatform(); // Renamed from GeneratePlatform
    const std::vector<Brick>& GetBricks() const;

    // Added Clear function for safe world regeneration
    void Clear();

private:
    std::vector<Brick> bricks;
    btDiscreteDynamicsWorld* physicsWorld; // Pointer to the physics world
    std::vector<btCollisionShape*> collisionShapes; // To manage shapes created by World
    std::vector<btDefaultMotionState*> motionStates; // To manage motion states created by World
    std::vector<btRigidBody*> rigidBodies; // To manage rigid bodies created by World
};
--------------------------------------------------------------------------------

// File: main.cpp
--------------------------------------------------------------------------------
#define _WINSOCKAPI_
#define _WINSOCK_DEPRECATED_NO_WARNINGS

#include "Server.h"
#include "StudcraftBrickSystem.h" // Add this include

int main(){
    StudcraftBrickCatalog::GetInstance().Initialize();
    Server* s = new Server();
    s->Startup();
    s->Run();
    delete s;
    return 0;
}
--------------------------------------------------------------------------------
