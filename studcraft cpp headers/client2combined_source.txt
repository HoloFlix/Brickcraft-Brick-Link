
// File: ShaderLoader.cpp
--------------------------------------------------------------------------------
#include "ShaderLoader.h"
#include <fstream>
#include <sstream>
#include <iostream>

GLuint ShaderLoader::Load(const std::string& vertexPath, const std::string& fragmentPath) {
    std::ifstream vFile(vertexPath), fFile(fragmentPath);
    std::stringstream vStream, fStream;
    vStream << vFile.rdbuf();
    fStream << fFile.rdbuf();
    std::string vCode = vStream.str(), fCode = fStream.str();

    GLuint vertex = glCreateShader(GL_VERTEX_SHADER);
    const char* vStr = vCode.c_str();
    glShaderSource(vertex, 1, &vStr, nullptr);
    glCompileShader(vertex);

    GLuint fragment = glCreateShader(GL_FRAGMENT_SHADER);
    const char* fStr = fCode.c_str();
    glShaderSource(fragment, 1, &fStr, nullptr);
    glCompileShader(fragment);

    GLuint program = glCreateProgram();
    glAttachShader(program, vertex);
    glAttachShader(program, fragment);
    glLinkProgram(program);

    glDeleteShader(vertex);
    glDeleteShader(fragment);

    return program;
}
--------------------------------------------------------------------------------

// File: ShaderLoader.h
--------------------------------------------------------------------------------
#pragma once
#include <string>
#include <GL/glew.h>

class ShaderLoader {
public:
    static GLuint Load(const std::string& vertexPath, const std::string& fragmentPath);
};
--------------------------------------------------------------------------------

// File: main.cpp
--------------------------------------------------------------------------------
// --- Linker ---
#pragma comment(lib, "SDL2.lib")
#pragma comment(lib, "SDL2main.lib")
#pragma comment(lib, "opengl32.lib")
#pragma comment(lib, "glu32.lib")
#pragma comment(lib, "Ws2_32.lib")
#pragma comment(lib, "glew32.lib")

// ADDED: To suppress fopen warning if not using fopen_s
#define _CRT_SECURE_NO_WARNINGS

// Define M_PI if it's not already defined by cmath/math.h
#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

// --- Includes ---
#include <iostream>
#include <vector>
#include <cmath>
#include <map>
#include <algorithm>
#include <cstdio>

#include "GL/glew.h"
#define NOMINMAX
#include "SDL.h"
#include "SDL_opengl.h"
#include <gl/GLU.h>

#include "RakPeerInterface.h"
#include "MessageIdentifiers.h"
#include "BitStream.h"
#include "RakNetTypes.h"
#include "btBulletCollisionCommon.h"

#include "DataTypes.h"
#include "StudcraftBrickSystem.h" // Use the correct brick system
#include "ShaderLoader.h"

// Protocol IDs
const unsigned char ID_PLAYER_ACTION = 0x88;
const unsigned char ID_SERVER_WORLD_DATA = 0x82;
const unsigned char ID_PLAYER_STATES = 0x89;
const unsigned char ID_PLAYER_DISCONNECT_NOTIFICATION = 0x90;

// Globals
RakNet::RakPeerInterface* g_peer = nullptr;
SDL_Window* g_window = nullptr;
SDL_GLContext g_context;
bool g_is_connected = false;
bool g_quit_app = false;
std::vector<Brick> g_world_bricks;

GLuint g_shader_program;
GLint g_loc_model_matrix;
GLint g_loc_view_matrix;
GLint g_loc_projection_matrix;
GLint g_loc_color_id;
GLint g_loc_color_palette;
GLuint g_colorPaletteTextureID = 0;

PlayerState g_self_state;
std::map<RakNet::RakNetGUID, PlayerState> g_other_players;

float g_current_yaw = 0.0f;
float g_current_pitch = 0.0f;

// --- NEW Local Player State (from research) ---
btVector3 g_local_view_direction(0, 0, -1);
float g_local_dir_x = 0.0f;
float g_local_dir_y = 0.0f;

// Forward Declarations
void Render();
void SendInputToServer(float dYaw, float dPitch);
void HandleNetworkPacket(RakNet::Packet* packet);
GLuint LoadBMPAs1DTexture(const char* imagepath);
void DrawCube(float scale_x, float scale_y, float scale_z);
void RenderPlayer(const PlayerState& state, bool is_self);


void DrawCube(float scale_x, float scale_y, float scale_z) {
    glPushMatrix();
    glScalef(scale_x * 0.5f, scale_y * 0.5f, scale_z * 0.5f);
    glBegin(GL_QUADS);
        glNormal3f(0.0f, 1.0f, 0.0f);
        glVertex3f( 1.0f, 1.0f,-1.0f); glVertex3f(-1.0f, 1.0f,-1.0f);
        glVertex3f(-1.0f, 1.0f, 1.0f); glVertex3f( 1.0f, 1.0f, 1.0f);
        glNormal3f(0.0f,-1.0f, 0.0f);
        glVertex3f( 1.0f,-1.0f, 1.0f); glVertex3f(-1.0f,-1.0f, 1.0f);
        glVertex3f(-1.0f,-1.0f,-1.0f); glVertex3f( 1.0f,-1.0f,-1.0f);
        glNormal3f(0.0f, 0.0f, 1.0f);
        glVertex3f( 1.0f, 1.0f, 1.0f); glVertex3f(-1.0f, 1.0f, 1.0f);
        glVertex3f(-1.0f,-1.0f, 1.0f); glVertex3f( 1.0f,-1.0f, 1.0f);
        glNormal3f(0.0f, 0.0f,-1.0f);
        glVertex3f( 1.0f,-1.0f,-1.0f); glVertex3f(-1.0f,-1.0f,-1.0f);
        glVertex3f(-1.0f, 1.0f,-1.0f); glVertex3f( 1.0f, 1.0f,-1.0f);
        glNormal3f(-1.0f, 0.0f, 0.0f);
        glVertex3f(-1.0f, 1.0f, 1.0f); glVertex3f(-1.0f,-1.0f, 1.0f);
        glVertex3f(-1.0f,-1.0f,-1.0f); glVertex3f(-1.0f, 1.0f,-1.0f);
        glNormal3f(1.0f, 0.0f, 0.0f);
        glVertex3f( 1.0f, 1.0f,-1.0f); glVertex3f( 1.0f,-1.0f,-1.0f);
        glVertex3f( 1.0f,-1.0f, 1.0f); glVertex3f( 1.0f, 1.0f, 1.0f);
    glEnd();
    glPopMatrix();
}

GLuint LoadBMPAs1DTexture(const char* imagepath) {
    unsigned char header[54];
    unsigned int dataPos, width, height, imageSize;
    unsigned char *data;

    FILE* file;
    if (fopen_s(&file, imagepath, "rb") != 0 || file == NULL) {
        std::cerr << "Image could not be opened: " << imagepath << std::endl;
        return 0;
    }
    if (fread(header, 1, 54, file) != 54 || header[0] != 'B' || header[1] != 'M') {
        std::cerr << "Not a correct BMP file: " << imagepath << std::endl;
        fclose(file);
        return 0;
    }
    dataPos = *(int*)&(header[0x0A]);
    imageSize = *(int*)&(header[0x22]);
    width = *(int*)&(header[0x12]);
    height = *(int*)&(header[0x16]);
    if (imageSize == 0) imageSize = width * height * 3;
    if (dataPos == 0) dataPos = 54;
    data = new unsigned char[imageSize];
    fread(data, 1, imageSize, file);
    fclose(file);

    GLuint textureID;
    glGenTextures(1, &textureID);
    glBindTexture(GL_TEXTURE_1D, textureID);
    glTexImage1D(GL_TEXTURE_1D, 0, GL_RGB, width, 0, GL_BGR, GL_UNSIGNED_BYTE, data);
    delete[] data;

    glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    return textureID;
}

void HandleNetworkPacket(RakNet::Packet* packet) {
    RakNet::BitStream bs_in(packet->data, packet->length, false);
    unsigned char msgId;
    bs_in.Read(msgId);
    
    switch (msgId) {
        case ID_CONNECTION_REQUEST_ACCEPTED:
            g_is_connected = true;
            g_self_state.guid = g_peer->GetMyGUID();
            std::cout << "Successfully connected. My GUID is: " << g_self_state.guid.ToString() << std::endl;
            break;
        case ID_NO_FREE_INCOMING_CONNECTIONS:
        case ID_CONNECTION_LOST:
            g_is_connected = false;
            g_quit_app = true;
            std::cout << "Disconnected from server." << std::endl;
            break;
        case ID_DISCONNECTION_NOTIFICATION:
            std::cout << "A peer has disconnected." << std::endl;
            break;
		case ID_SERVER_WORLD_DATA: {
			// **FIX:** Read the brick_count first, as this is what the corrected server sends.
			unsigned int brick_count;
			bs_in.Read(brick_count);

			g_world_bricks.clear();
			g_world_bricks.reserve(brick_count);

			for (unsigned int i = 0; i < brick_count; ++i) {
				Brick b;
				bs_in.Read((char*)&b, sizeof(Brick));
				g_world_bricks.push_back(b);
			}
			std::cout << "[WORLD] Received " << brick_count << " bricks from server." << std::endl;
			break;
		}
        case ID_PLAYER_STATES: {
            unsigned int num_players;
            bs_in.Read(num_players);
            std::map<RakNet::RakNetGUID, PlayerState> received_players;
            for(unsigned int i=0; i < num_players; ++i) {
                PlayerState ps;
                bs_in.Read((char*)&ps, sizeof(PlayerState));
                if(ps.guid == g_self_state.guid){
                    g_self_state = ps;
                } else {
                    received_players[ps.guid] = ps;
                }
            }
            g_other_players = received_players;
            break;
        }
        case ID_PLAYER_DISCONNECT_NOTIFICATION: {
            RakNet::RakNetGUID disconnected_guid;
            bs_in.Read(disconnected_guid);
            g_other_players.erase(disconnected_guid);
            std::cout << "Player with GUID " << disconnected_guid.ToString() << " gracefully disconnected." << std::endl;
            break;
        }
        default:
            std::cout << "Unhandled Message ID: " << (int)msgId << std::endl;
            break;
    }
}

void SendInputToServer(float dYaw, float dPitch) {
    const Uint8* keyState = SDL_GetKeyboardState(NULL);
    
    // **THE FIX:** Correctly initialize the struct and its btVector3 member.
    PlayerInput input;
    input.move_vector.setZero();
    input.is_jump_pressed = (keyState[SDL_SCANCODE_SPACE] != 0);

    btVector3 local_move(0, 0, 0);
    if (keyState[SDL_SCANCODE_W]) local_move.setZ(-1);
    if (keyState[SDL_SCANCODE_S]) local_move.setZ(1);
    if (keyState[SDL_SCANCODE_A]) local_move.setX(-1);
    if (keyState[SDL_SCANCODE_D]) local_move.setX(1);

    if (!local_move.isZero()) {
        local_move.normalize();
        btQuaternion yaw_rotation(btVector3(0, 1, 0), g_current_yaw * (3.14159f / 180.0f));
        input.move_vector = btMatrix3x3(yaw_rotation) * local_move;
    }

    RakNet::BitStream bs_out;
    bs_out.Write((unsigned char)ID_PLAYER_ACTION);
    bs_out.Write(input);
    g_peer->Send(&bs_out, LOW_PRIORITY, UNRELIABLE_SEQUENCED, 0, RakNet::UNASSIGNED_SYSTEM_ADDRESS, true);
}


void RenderPlayer(const PlayerState& state, bool is_self) {
    glPushMatrix();
    glTranslatef(state.position.x, state.position.y, state.position.z);
    
    btTransform body_transform(state.rotation);
    float mat[16];
    body_transform.getOpenGLMatrix(mat);
    glMultMatrixf(mat);

    float brick_height = 3.0f * PLATE_HEIGHT;
    for (int i = 0; i < 3; ++i) {
        if (is_self && i == 2) continue;
        glPushMatrix();
        float y_pos = (i - 1) * brick_height;
        glTranslatef(0, y_pos, 0);
        float final_model_view_mat[16];
        glGetFloatv(GL_MODELVIEW_MATRIX, final_model_view_mat);
        glUniformMatrix4fv(g_loc_model_matrix, 1, GL_FALSE, final_model_view_mat);
        glUniform1i(g_loc_color_id, (i == 2) ? 1 : 4);
        DrawCube(2.0f * STUD_UNIT, brick_height, 4.0f * STUD_UNIT);
        glPopMatrix();
    }
    glPopMatrix();
}

void Render() {
    int w, h;
    SDL_GetWindowSize(g_window, &w, &h);
    glViewport(0, 0, w, h);

    glClearColor(0.5f, 0.8f, 1.0f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    glUseProgram(g_shader_program);
    
    // --- 1. PROJECTION MATRIX ---
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(70.0, (GLdouble)w / h, 0.1, 1000.0);
    float proj[16];
    glGetFloatv(GL_PROJECTION_MATRIX, proj);
    glUniformMatrix4fv(g_loc_projection_matrix, 1, GL_FALSE, proj);

    // --- 2. VIEW MATRIX (The Stable FPS Camera using gluLookAt) ---
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    // a. Define the camera's position (the "eye") in the world.
    float eye_height = 1.8f; // A comfortable eye-height above the player's physics origin.
    btVector3 eye_pos(
        g_self_state.position.x,
        g_self_state.position.y + eye_height,
        g_self_state.position.z
    );

    // b. Calculate the point the camera is looking at (the "target") using trigonometry.
    float yaw_rad = g_current_yaw * (3.14159f / 180.0f);
    float pitch_rad = g_current_pitch * (3.14159f / 180.0f);

    btVector3 look_dir(
        sin(yaw_rad) * cos(pitch_rad),
        sin(pitch_rad),
        -cos(yaw_rad) * cos(pitch_rad)
    );
    btVector3 target_pos = eye_pos + look_dir;

    // c. Build the stable view matrix. This is the definitive fix for the orbit/lean bug.
    gluLookAt(
        eye_pos.x(), eye_pos.y(), eye_pos.z(),          // Eye Position
        target_pos.x(), target_pos.y(), target_pos.z(), // Target Position
        0.0f, 1.0f, 0.0f                               // World's "Up" direction
    );
    
    // The GL_MODELVIEW matrix now IS our final View Matrix for the frame.
    float view[16];
    glGetFloatv(GL_MODELVIEW_MATRIX, view);
    glUniformMatrix4fv(g_loc_view_matrix, 1, GL_FALSE, view);
    
    // --- 3. RENDER WORLD & PLAYERS ---
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_1D, g_colorPaletteTextureID);
    glUniform1i(g_loc_color_palette, 0);

    for(size_t i = 0; i < g_world_bricks.size(); ++i) {
        const Brick& brick_data = g_world_bricks[i];
        glPushMatrix();
        glTranslatef(brick_data.x, brick_data.y, brick_data.z);
        float model_view_mat[16];
        glGetFloatv(GL_MODELVIEW_MATRIX, model_view_mat);
        glUniformMatrix4fv(g_loc_model_matrix, 1, GL_FALSE, model_view_mat);
        glUniform1i(g_loc_color_id, brick_data.c_id);
        DrawCube(2.0f * STUD_UNIT, 1.0f * PLATE_HEIGHT, 2.0f * STUD_UNIT);
        glPopMatrix();
    }
    for (std::map<RakNet::RakNetGUID, PlayerState>::const_iterator it = g_other_players.begin(); it != g_other_players.end(); ++it) {
        RenderPlayer(it->second, false);
    }
    
    glUseProgram(0);
    SDL_GL_SwapWindow(g_window);
}

int SDL_main(int argc, char* argv[]) {
    StudcraftBrickCatalog::GetInstance().Initialize();

    SDL_Init(SDL_INIT_VIDEO);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 2);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 1);
    SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);
    g_window = SDL_CreateWindow("Studcraft Client", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 1280, 720, SDL_WINDOW_OPENGL | SDL_WINDOW_SHOWN);
    g_context = SDL_GL_CreateContext(g_window);
    glEnable(GL_DEPTH_TEST);

    glewExperimental = GL_TRUE;
    GLenum err = glewInit();
    if (GLEW_OK != err) {
        std::cerr << "Error: " << glewGetErrorString(err) << std::endl;
        return 1;
    }

    g_shader_program = ShaderLoader::Load("assets/shaders/brick.vert", "assets/shaders/brick.frag");
    g_colorPaletteTextureID = LoadBMPAs1DTexture("assets/LegoColors.bmp");

    g_loc_model_matrix = glGetUniformLocation(g_shader_program, "model");
    g_loc_view_matrix = glGetUniformLocation(g_shader_program, "view");
    g_loc_projection_matrix = glGetUniformLocation(g_shader_program, "projection");
    g_loc_color_id = glGetUniformLocation(g_shader_program, "color_id");
    g_loc_color_palette = glGetUniformLocation(g_shader_program, "colorPalette");
    
    g_peer = RakNet::RakPeerInterface::GetInstance();
    RakNet::SocketDescriptor sd;
    g_peer->Startup(1, &sd, 1);
    g_peer->Connect("127.0.0.1", 37373, 0, 0);
    g_local_view_direction.setValue(0,0,-1); // Add this line
    SDL_SetRelativeMouseMode(SDL_TRUE);
    
    while (!g_quit_app) {
        float frame_delta_yaw = 0.0f;
        float frame_delta_pitch = 0.0f;

		SDL_Event e;
		while(SDL_PollEvent(&e) != 0) {
			if(e.type == SDL_MOUSEMOTION) {
				// The client updates its own yaw and pitch for immediate camera feedback.
				g_current_yaw   += (float)e.motion.xrel * 0.2f;
				g_current_pitch -= (float)e.motion.yrel * 0.2f; // Use -= to invert Y-axis
			}
            if (e.type == SDL_QUIT) {
                g_quit_app = true;
            }
		}

		g_current_pitch = std::max(-89.0f, std::min(89.0f, g_current_pitch));

		for (RakNet::Packet* p = g_peer->Receive(); p; g_peer->DeallocatePacket(p), p = g_peer->Receive()) {
            HandleNetworkPacket(p);
        }

        if (g_is_connected) {
            SendInputToServer(frame_delta_yaw, frame_delta_pitch);
        }

        Render();
        SDL_Delay(15);
    }
    
    glDeleteProgram(g_shader_program);
    glDeleteTextures(1, &g_colorPaletteTextureID);
    RakNet::RakPeerInterface::DestroyInstance(g_peer);
    SDL_GL_DeleteContext(g_context);
    SDL_DestroyWindow(g_window);
    SDL_Quit();
    return 0;
}
--------------------------------------------------------------------------------
