The Studcraft Engine: v1.0 Documentation
1. Project Overview & Philosophy
Project Name: Studcraft (formerly known as the "Brickcraft Phoenix Protocol").
Core Objective: To build a modern, open-source, and compatible server and client for the 2012 "Rex Kwon Do" / Brickcraft game prototype.
Current Status (v1.0): SUCCESS. The project has achieved its primary goal. We have a stable, custom-built C++ server application (StudcraftServer) and a custom C++ client (StudcraftClient) that successfully communicate using a reverse-engineered model of the original game's network protocol.
Development Philosophy: This project is a testament to meticulous reverse-engineering, iterative development, and persistent debugging. It honors the architectural decisions of the original prototype while leveraging modern C++ practices for stability and clarity. Our guiding principle has been: "The original client works perfectly with the original server; therefore, any deviation in behavior is a flaw in our understanding, not a bug in the client." This principle has successfully guided the project through numerous complex challenges to a victorious conclusion.
2. System Architecture
The Studcraft Engine is a client-server application built in C++ within a single Visual Studio 2010 solution, ensuring period-correct compilation. It is comprised of four modular projects:
RakNet (Static Library): A period-correct build of the RakNet 3 networking library, compiled directly from our own source tree. This guarantees 100% network protocol compatibility.
BulletPhysics (Static Library): A period-correct build of the Bullet Physics 2.78 library, also compiled from source. This provides the real-time physics simulation that governs all dynamic objects.
StudcraftServer (Executable): Our new, custom-built server application. It is the authoritative source of all game state. It owns and orchestrates all core systems, including the world state, physics simulation, and player management.
StudcraftClient (Executable): Our new, custom-built client application. It uses the SDL2 library for windowing and input, and legacy OpenGL for 3D rendering. Its purpose is to connect to the server, receive state information, send user input, and render the game world.
Server Architecture:
The server is designed with a clean, object-oriented structure:
Server Class: The central "brain" of the application. It owns all other systems and manages the main application loop, dispatching network messages and stepping the physics simulation.
World Class: A simple data container responsible for generating and storing the static geometry of the game world (the collection of Brick structs). In v1.0, this procedurally generates a 16x16 platform.
Player Class: This represents a connected user. It is a dynamic, physics-based object inheriting from RakNet::Replica3. This inheritance is critical, as it allows the RakNet ReplicaManager3 to automatically synchronize the player's state (like position and orientation) from the server to the client. Each Player owns a btRigidBody in the physics simulation.
ReplicaManager Helpers (StudcraftConnection, StudcraftReplicaManager): These small classes fulfill the RakNet "contract," telling the replication system how to create our custom Connection and Player objects when new data arrives.
3. The Studcraft Network Protocol (The "Conversation")
The protocol is the strict sequence of events that allows the client and server to establish a connection and enter an interactive game state. Deviating from this sequence will cause the client to stall or disconnect.
The Definitive Handshake and Spawn Sequence:
Step 1: Connection. The StudcraftClient initiates a standard RakNet connection to the server on port 37373. The StudcraftServer receives ID_NEW_INCOMING_CONNECTION.
Step 2: Server Takes Authority. The server does not wait. It immediately takes charge of the protocol flow and sends two crucial packets back-to-back:
Packet A: The World (ID = 0x82)
The server sends a large, RELIABLE_ORDERED packet with the message ID 0x82.
This packet contains the entire static world geometry, serialized as:
A Vector3 (12 bytes) representing the initial spawn camera position hint.
An unsigned int (4 bytes) representing the total brick_count.
A continuous stream of all N raw, 32-byte Brick structs.
Packet B: The Player (ReplicaManager3 Construction)
Simultaneously, the server creates a server-side Player object and its btRigidBody.
It calls replicaManager->Reference(player).
The ReplicaManager3 plugin automatically detects this new object and sends a network construction packet to the client. This packet instructs the client to create its own local proxy representation of the new Player object.
Step 3: The Victory Condition.
The client receives the 0x82 world and the Player construction packet. Its state machine is now satisfied. It has the map data, and it has an object representing itself.
The client enters its "active" game state and begins sending a continuous stream of 0x88 packets.
The server receiving its very first ID_PLAYER_ACTION (0x88) packet is the definitive [VICTORY] condition. This is the proof that the client is spawned, alive, and ready to be controlled.
Step 4: The Gameplay Loop (The "Heartbeat").
Client -> Server: Every frame, the client sends an 0x88 packet containing a PlayerInput struct with the state of its keyboard (WASD, Space) and mouse movement (delta_yaw).
Server -> Client: The ReplicaManager3 on the server automatically detects changes to any replicated object's physics state (i.e., when the player moves). It automatically serializes the btTransform (position and orientation) of the player's btRigidBody and sends it to the client. This ongoing stream of ReplicaManager updates acts as our server heartbeat and keeps the client's view of the player perfectly synchronized with the server's authoritative physics simulation.