#include "World.h"
#include "btBulletDynamicsCommon.h" // Include the full header for implementation

// Default constructor (NEW)
World::World() : physicsWorld(nullptr) {}

// The constructor now takes the physics world and stores it.
World::World(btDiscreteDynamicsWorld* dynamicsWorld) : physicsWorld(dynamicsWorld) {}

// Destructor to clean up physics objects created by this World
World::~World() {
    // Remove rigid bodies from the physics world first
    if (physicsWorld) {
        for (size_t i = 0; i < rigidBodies.size(); ++i) {
            physicsWorld->removeRigidBody(rigidBodies[i]);
        }
    }

    // Delete allocated physics objects
    for (size_t i = 0; i < rigidBodies.size(); ++i) {
        delete rigidBodies[i];
    }
    for (size_t i = 0; i < motionStates.size(); ++i) {
        delete motionStates[i];
    }
    for (size_t i = 0; i < collisionShapes.size(); ++i) {
        delete collisionShapes[i];
    }

    rigidBodies.clear();
    motionStates.clear();
    collisionShapes.clear();
}


void World::GenerateSimplePlatform() {
    // Clear existing bricks and physics objects if regenerating the world
    // This is important if GenerateSimplePlatform can be called multiple times
    // without recreating the World object itself.
    // Call destructor logic to clean up current physics objects
    this->~World(); // Call destructor to clean up current physics objects
    // Re-initialize vectors after cleanup
    bricks.clear();
    collisionShapes.clear();
    motionStates.clear();
    rigidBodies.clear();


    const int world_size = 16;
    const float brick_step = 2.0f;

    for (int i = -world_size / 2; i < world_size / 2; ++i) {
        for (int j = -world_size / 2; j < world_size / 2; ++j) {
            Brick floor_tile = {0};
            floor_tile.x = (float)i * brick_step;
            floor_tile.y = 0.0f; // Position of the visual brick
            floor_tile.z = (float)j * brick_step;

            // FIX: Use the correct member names from DataTypes.h
            floor_tile.id = 1;
            floor_tile.c_id = 7;

            bricks.push_back(floor_tile);

            // --- THIS IS THE NEW LOGIC FOR PHYSICS BODIES ---
            // Ensure physicsWorld is valid before creating physics bodies
            if (this->physicsWorld) {
                // 1. Define the shape. A box of 1x0.1x1 units. The Y-size is small
                //    since it's a flat tile. btBoxShape takes half-extents, so divide by 2.
                btCollisionShape* groundShape = new btBoxShape(btVector3(1.0f, 0.1f, 1.0f));
                collisionShapes.push_back(groundShape); // Store for cleanup

                // 2. Set its position in the world. It must match the visual brick's position.
                // Note: Bullet uses the center of the shape. If floor_tile.y is the bottom,
                // adjust origin by half the height of the box.
                btTransform groundTransform;
                groundTransform.setIdentity();
                groundTransform.setOrigin(btVector3(floor_tile.x, floor_tile.y + 0.1f, floor_tile.z)); // +0.1f for half height

                // 3. Mass is 0 for a static object.
                btScalar mass(0.0);
                btVector3 localInertia(0, 0, 0); // Static objects have zero inertia

                // 4. Create the body and add it to the physics world.
                btDefaultMotionState* myMotionState = new btDefaultMotionState(groundTransform);
                motionStates.push_back(myMotionState); // Store for cleanup

                btRigidBody::btRigidBodyConstructionInfo rbInfo(mass, myMotionState, groundShape, localInertia);
                btRigidBody* body = new btRigidBody(rbInfo);
                rigidBodies.push_back(body); // Store for cleanup

                this->physicsWorld->addRigidBody(body);
            }
        }
    }
}

const std::vector<Brick>& World::GetBricks() const { return bricks; }